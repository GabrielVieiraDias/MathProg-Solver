<!DOCTYPE HTML>
<html>

<head>
    <meta http-equiv='Content-Type' content='text/html' charset='UTF-8' />
    <title>MathProg</title>
    <style>
        html,
        body {
            width: 100%;
            height: 100%;
            overflow: hidden;
        }
        
        #container {
            position: absolute;
            top: 0;
            bottom: 0;
            left: 0;
            right: 0;
            overflow: scroll;
        }
        
        table,
        th,
        td {
            font-size: 13px;
        }
        
        td {
            width: auto;
            min-width: 200px;
        }
        
        td+td {
            min-width: 50px;
            width: auto;
        }
        
        .mathprog,
        .exercise {
            visibility: hidden;
            display: none;
        }
        
        #container {
            margin: auto;
        }
        
        #linkTextArea {
            height: 80px;
            width: 490px;
        }
        
        #content {
            clear: left;
            width: 750;
            padding-top: 0px;
            padding-left: 15px;
            padding-right: 15px;
        }
        
        #output {
            font-family: Consolas, Monaco, "Courier New", monospace;
            font-size: 13px;
            width: 100%;
        }
        
        #log {
            font-family: Consolas, Monaco, "Courier New", monospace;
            font-size: 13px;
            width: 100%;
        }
        
        #instructionContent {
            width: 100%;
        }
        
        #instructionContent>h1 {
            font-size: 20pt;
        }
        
        #instructionContent>h2 {
            font-size: 18pt;
        }
        
        #instructionContent>h3 {
            font-size: 16pt;
        }
        
        #instructionContent>h4 {
            font-size: 14pt;
        }
        
        #instructionContent>h5 {
            font-size: 12pt;
        }
        
        #instructionContent>h6 {
            font-size: 10pt;
        }
        
        #instructionContent>blockquote {
            font-size: 10pt;
        }
    </style>
    <script src="libs/FileSaver.js-master/src/FileSaver.js"></script>
    <script src="libs/jQuery/2.2.3/jquery-2.2.3.min.js"></script>
    <script src="libs/jQuery-UI/1.11.4/jquery-ui.min.js"></script>
    <link href="libs/jQuery-UI/1.11.4/jquery-ui.css" rel="stylesheet">
    <script src="libs/Bootstrap/3.3.4/bootstrap.min.js"></script>
    <script src="libs/smartmenus-1.0.0/jquery.smartmenus.min.js"></script>
    <script src="libs/smartmenus-1.0.0/addons/bootstrap/jquery.smartmenus.bootstrap.min.js"></script>
    <link href="libs/Bootstrap/3.3.4/bootstrap.min.css" rel="stylesheet">
    <link href="libs/smartmenus-1.0.0/addons/bootstrap/jquery.smartmenus.bootstrap.css" rel="stylesheet">
    <link href="css/mathprog.css" rel="stylesheet">
    <style>
        pre {
            font-family: Consolas, Monoco, "Courier New";
            font-size: 13px;
            line-height: 1.45em;
        }
    </style>
    <script src="libs/CodeMirror/5.13.4/codemirror.min.js"></script>
    <link href="libs/CodeMirror/5.13.4/codemirror.min.css" rel="stylesheet">
    <script src="libs/CodeMirror/codemirror_mathprog.js"></script>
    <style>
        .CodeMirror {
            font-size: 13px;
            font-family: Consolas, Monaco, "Courier New", monospace;
            line-height: 1.45em;
            width: 100%;
            margin: 0px;
            border: solid 1px;
        }
    </style>
    <!--<script src="libs/Marked/0.3.5/marked.min.js"></script> -->
    <script src="libs/markdown-it/6.0.1/markdown-it.min.js"></script>
    <link href="libs/KaTeX/0.5.1/katex.min.css" rel="stylesheet">
    <script src="libs/KaTeX/0.5.1/katex.min.js"></script>
    <script src="libs/KaTeX/0.5.1/auto-render.min.js"></script>
    <script src="libs/filepicker.js"></script>
    <script src="libs/jsapi.js"></script>
    <script src='libs/glpk.min.js'></script>
</head>

<body>

    <!-- modal Sobre... -->
    <div id="modalAbout" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="model-content" style="background: #fff; border-radius:20px;">
                <div class="modal-header" style="padding-top: 10px;">
                    <h3>Sobre...</h3>
                </div>
                <div class="modal-body">
                    <p>
                        <b>MathProg Solver</b> é uma aplicação para otimiza&ccedil;&atilde;o linear e discreta no GNU MathProg, a linguagem de modelagem do projeto GLPK de c&oacute;digo aberto. A sintaxe &eacute; similar a <a href="http://www.ampl.com/"
                            target='_blank'>AMPL</a>. Os c&aacute;lculos são realizados no aplicativo usando o solucionador glpk.js.
                    </p>
                    <p>
                        Este projeto usa bibliotecas de c&oacute;digo aberto, incluindo:
                    </p>
                    <ul>
                        <li> <a href='http://www.gnu.org/software/glpk/' target='_blank'>GNU GLPK project</a></li>
                        <li> <a href='https://github.com/hgourvest/glpk.js' target='_blank'>glpk.js</a></li>
                        <li> <a href='http://jquery.com/' target='_blank'>jQuery</a></li>
                        <li> <a href='http://twitter.github.com/bootstrap/' target='_blank'>Bootstrap</a></li>
                        <li> <a href='https://khan.github.io/KaTeX/' target='_blank'>KaTeX</a></li>
                    </ul>

                    <p>Este projeto foi baseado no projeto disponível no GitHub do jckantor. Link para o projeto original: <a target="_blank" href="https://github.com/jckantor/MathProg-Solver.git">https://github.com/jckantor/MathProg-Solver.git</a></p>
                </div>
                <div class="modal-footer">
                    <button class="btn btn-primary" data-dismiss="modal">Fechar</button>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Confirmar limpeza do editor -->
    <div id="modalConfirmClearAll" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div class="modal-header" style="padding-top: 10px;">
                    <h3>Existem altera&ccedil;&otilde;es a serem salvas...</h3>
                </div>
                <div class="modal-body">
                    <p>
                        Voc&ecirc; vai perder todas as suas altera&ccedil;&otilde;es. Tem certeza que deseja limpar o editor?
                    </p>
                </div>
                <div class="modal-footer">
                    <button id='btnModalConfirmClearAll' class="btn" data-dismiss="modal" style='margin-right:10px;'>N&atilde;o salvar altera&ccedil;&otilde;es</button>
                    <button class="btn btn-primary" data-dismiss="modal">Cancelar</button>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleHelloWorld" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div class="modal-header" style="padding-top: 10px;">
                    <h3>Hello World</h3>
                </div>
                <div id="helloWorld" class="modal-body modal-body-example">
                    <p>

                        <p>/*# Hello, World</p>

                        <p>This is one of the simplest MathProg models one can write. Thw `printf` statement prints information to the model output. Note the use of `\n` to separate lines of output.
                        </p>
                        <p>
                            * The first statement is a comment. MathProg ignores everything on a line following a hash tag `#` * Every statement ends with a semicolon `;` * The end of model is indicated by the `end;` statement. * There is a final new line following the `end;` statement.
                        </p>
                        <p>
                            Experiment with this simple file. Try adding additional lines of output including blank lines. See what happens if you leave out a needed semicolon or the final `end;` statement.
                        </p>
                        On *MathProg Solver* you will find the output under the tab labelled Output. */

                        <p><b>
  printf "Hello, World!\n";
  <p>end;</p>
  
</b>
                        </p>
                    </p>
                </div>
                <div class="modal-footer">
                    <button id='btnCopycode' class="btn btn-success" onclick="copiarExemplo('helloWorld')" data-dismiss="modal" style='margin-right:10px;'>Copiar</button>
                    <button class="btn btn-primary" data-dismiss="modal">Cancelar</button>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExample2variable" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="lpTwoVars" class="modal-body modal-body-example">
                    <p>/*# Linear Program in Two Variables</p>

                    <p>Write a MathProg model to find the maximum value of \\(z=3x + 4y\\) subject to the following set of constraints
                    </p>
                    <p>
                        \\[x + 2y \leq 14 \\]<br> \\[3x - y \geq 0 \\]<br> \\[x - y \leq 2 \\]<br>
                    </p>
                    <p>
                        The maximum value of \\(z\\) is 34. What are the corresponding values of \\(x\\) and \\(y\\)? What is the minimum value of \\(z\\)? */
                    </p>
                    <p>
                        # Define Variables<br> var x;<br> var y;
                    </p>
                    <p>
                        <b>
# Define Constraints
s.t. A: x + 2*y <= 14;<br>
s.t. B: 3*x - y >= 0;<br>
s.t. C: x - y <= 2;<br>

# Define Objective<br>
maximize z: 3*x + 4*y;<br>

# Solve<br>
solve;<br>

<p>end;</p>

  </b>
                    </p>
                    </p>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleLinearEqns" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="linearEqns" class="modal-body modal-body-example">
                    <p>/* # Solving a System of Linear Equations MathProg is a language for describing linear and discrete optimization problems. A series of exercises described below will introduce MathProg by demonstrating how to solve to small system
                        of linear equations. Consider a set of three linear equations
                    </p>

                    <p>
                        \\[ 2x + y + z = 12\\]<br> \\[ x + 2y + z = 23 \\]<br> \\[ x + y + z = 10 \\]<br>
                    </p>
                    <p>
                        in the three unknowns \\(x\\), \\(y\\), and \\(z\\).<br> To find a solution with MathProg you need to create a description of the problem. For this case the description consists of<br>
                    </p>
                    <p>
                        1. a description of the variables, <br> 2. a description of the equations,<br> 3. additional keywords indicating the desired actions, and <br> 4. comments necessary for someone to understand the description. <br> These points are
                        demonstrated in the MathProg model shown below. <br><br> Note the following points as you examine this model &mdash;<br><br> * The hashtags denote comments. Anything following the hashtag on the same line is ignored by MathProg.<br>                        * Semicolons separate statements in MathProg. A MathProg statement may continue over several lines.<br> * The statements starting with the keyword `var` describe variables appearing in the problem. There is a separate line for
                        each variable.<br> * The next group of statements describe equations appearing in the problem. Each statement begins with a name of an equation separated by a colon from the equation itself. The equations are written in standard
                        computer notation. Each equation must have a name.<br> * The keyword `solve` indicates a solution is to be computed.<br> * The keyword `end` indicates completion of the problem description.<br><br> Here are a few exercises to try
                        <br><br> 1. Click the Solve button underneath the editor. Locate the solution for \\(x\\),<br> \\(y\\), and \\(z\\) in the tab labeled 'Variables'. In the constraints tab locate<br> the solution for each equation.<br> 2. Change
                        the equations. Explore how the solution changes depends on equation<br> parameters. See what happens when two of the equations are identical.<br> 3. The Wikipedia page [Systems of Linear Equations](http://en.wikipedia.org/wiki/System_of_linear_equations)
                        showes some example problems. Click `New Model`, then write a MathProg model from scratch to solve one of the examples.<br> */
                    </p>
                    <p>
                        <b>

# List the variables<br>
var x;<br>
var y;<br>
var z;<br>

# List the equations<br>
Eq1:  2*x +   y +  z = 12;<br>
Eq2:    x + 2*y +  z = 23;<br>
Eq3:    x +   y +  z = 10;<br><br>

# Solve<br>
solve;<br><br>

end;<br>

</b>
                    </p>
                    </p>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleSets" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="sets" class="modal-body modal-body-example">
                    <p>/* # Set Operations in MathProg</p>

                    <p>Sets are a basic concept in mathematical programming languages. Sets are used to define the objects of discourse in a particular application. A convenient notation to is name sets in all caps so they are readily distinguished from
                        variables and parameters appearing in an application.
                    </p>
                    <p>This example demonstrates several basic and useful set manipulations in MathProg:
                    </p>
                    <p>
                        * `union`: the union of sets<br> * `card` : the cardinality (i.e, number of elements) of a set<br> * : intersection of sets<br> * : difference of sets<br> * : symmetric difference of sets<br> */
                    </p>
                    <p>
                        <b>
set DOGS := {'Beagle','Labrador','Shepherd','Boxer'};<br>
set CATS := {'Tiger','Lion'};<br>
set FISH := {'Goldfish','Guppy','Shark'};<br>

# Union of Sets<br>

set PETS := DOGS union CATS union FISH;<br>

printf "PETS: ";<br>
for {pet in PETS} printf "%4s ", pet;<br>

# Cardinality of a Set<br>

printf "\n\nNumber of Pets: %d", card(PETS);<br>

set DANGEROUS := {'Tiger','Lion','Shark','Crocodile'};<br>

# Intersection<br>

# Difference of Sets<br>
set SAFE := PETS diff DANGEROUS;<br>

printf "\n\nSAFE: ";<br>

for {pet in SAFE} printf "%4s ",pet;<br>

# Symmetric Difference of Sets<br>

printf "\n\n";<br>
end;
</b>
                    </p>
                    </p>
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleParameters" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="parameters" class="modal-body modal-body-example">
                    <p>/* # Working with Parameters */</p>

                    <p>/* Define sets */</p>

                    <p>
                        set STUDENTS; <br> set COURSES;<br>
                    </p>
                    <p>
                        /* Declare Parameters */<br><br> param credits{c in COURSES} >= 0;<br> param schedules{s in STUDENTS, c in COURSES} binary;<br>
                    </p>
                    <p>


                        /* Computed Parameter */<br><br> param loads{s in STUDENTS} := sum{c in COURSES} schedules[s,c]*credits[c];<br><br> /* Report Results */<br><br> printf "STUDENTS\n";<br> printf {student in STUDENTS} " %-10s %3d \n",student,loads[student];<br><br>                        printf "\nCOURSES\n";<br> printf {c in COURSES} " %s\n",c;<br> printf "\n\n";<br><br> /* Data Section */<br><br> data;

                        <br><br> set STUDENTS := Alex Brian Carl Diane Emil Francine;<br> set COURSES := Math English Chemistry Physics;<br><br> param credits :=<br> Math 3<br> English 3<br> Chemistry 4<br> Physics 5 ;<br><br> param schedules: Math English
                        Chemistry Physics :=<br> Alex 1 1 0 0<br> Brian 0 0 1 1<br> Carl 1 0 0 1<br> Diane 0 1 1 1<br> Emil 1 0 1 0<br> Francine 0 1 1 0 ;<br><br> end;

                        <br>
                    </p>
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleChartTools" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="chartTools" class="modal-body modal-body-example">
                    <p>/* # Chart Tools</p>

                    <p> The table driver GCHART creates charts using Google Chart Tools. The chart<br> options are specified using the MathProg table syntax <br><br> table tname {x in X} OUT "GCHART" title chartType options : x~fld, y[x]~Y, ...<br><br> where
                        <br><br> title: A required string to be used a title of the chart<br> chartType: An optional string specifying the chart type. Consult the Google<br> Chart Tools documentation for a list of valid types.<br> options: An optional
                        string in JSON format of options. Consult the Google<br> Chart Tools for documentation.<br><br> Consult the GMPL Language Reference for details regarding MathProg's table<br> statement.
                        <br><br> */
                    </p>

                    <p>
                        # Line Chart - Simple, no options<br> table t01 {x in 0..10 by 0.1} OUT "GCHART" "Mathematical Functions" "LineChart" : <br> x~Radians, sin(x), cos(x);<br>
                    </p>
                    <p>
                        # Table - Create<br><br> set MONTHS;<br> param Temp{MONTHS};<br> param Precip{MONTHS};<br> table t03 {m in MONTHS} OUT "GCHART" "Weather Data for International Falls, MN, USA" "Table":<br> m~Month, Temp[m]~Temperature, Precip[m]~Precipitation;<br><br>
                    </p>
                    <p>
                        # Column Chart with options<br> param t04_options symbolic := "{vAxis: {title: 'Temperature (C)'}}";<br> table t04 {m in MONTHS} OUT "GCHART" "International Falls, MN, USA" "ColumnChart" t04_options:<br> m~Month, (5/9)*(Temp[m]-32)~Temperature;<br>
                    </p>

                    <p>

                        # Bar Chart<br> table t05 {m in MONTHS} OUT "GCHART" "International Falls, MN, USA" "BarChart"<br> "{height: 400}": m~Month, Temp[m]~Temperature;<br><br> # Combo Chart<br> param cc_options symbolic := """<br> { legend: {position:
                        'in'},
                        <br> seriesType: 'bars',<br> vAxes: {0: {title: 'Temperature (F)'}, <br> 1: {title: 'Precipitation (in)'}},<br> series: {0: {type: 'bar'}, <br> 1: {type: 'area', targetAxisIndex: 1}}<br> } """;<br> table tab6 {m in MONTHS} OUT
                        "GCHART" "International Falls, MN, USA" "ComboChart" cc_options: <br> m~Month, <br> Temp[m]~Temperature,
                        <br> Precip[m]~Precipitation;
                        <br><br> # Pie Chart<br> table t07 {m in {'Jun','Jul','Aug'}} OUT "GCHART" "Summer Precipitation" "PieChart" : <br> m~Month, Precip[m]~Precipitation;<br><br> # Scatter Chart with Options<br> param sc_options symbolic := """<br>                        { vAxis: {title: 'Temperature (F)'},<br> hAxis: {title: 'Precipitation (inches)'},<br> height: 480, <br> width: 640 } """;<br> table t08 {m in MONTHS} OUT "GCHART" "Precipitation vs. Temperature" "ScatterChart" sc_options: <br>                        Temp[m]~Temperature,
                        <br> Precip[m]~Precipiation;
                        <br><br> # Gauge <br> set DATA := {'AveTemp (F)', 'AnnPrecip (in)'};<br> var x{DATA};<br> s.t. A: x['AveTemp (F)'] = (sum {m in MONTHS} Temp[m])/card(MONTHS);<br> s.t. B: x['AnnPrecip (in)'] = sum {m in MONTHS} Precip[m];<br> solve;
                        <br> table tab9 {d in DATA} OUT "GCHART" "Annual Weather Summary" "Gauge" : d, x[d];<br><br> # Geo Chart - Regions<br> set BRIC := {'Brazil','Russia','India','China'};<br> table tab10 {s in BRIC} OUT "GCHART" "BRIC Countries" "GeoChart"
                        : s, Uniform(1,2)~Data;<br><br> # Geo Chart - Markers<br> set ACC := {<br> 'Atlanta','Blacksburg','Boston','Chapel Hill','Charlottesville',<br> 'Clemson','College Park','Durham','Miami','Pittsburgh','Syracuse',<br> 'Raleigh','South
                        Bend','Tallahassee','Winston-Salem'};
                        <br> param g_options symbolic := """<br> { region: 'US',<br> displayMode: 'markers',<br> colorAxis: {colors: ['green', 'blue']} }""";<br> table tab11 {s in ACC} OUT "GCHART" "Atlantic Coast Conference" "GeoChart" g_options: s,
                        1~Data;
                        <br><br> data;

                        <br><br> param : MONTHS : Temp Precip :=<br> Jan 1.0 0.9<br> Feb 7.7 0.6<br> Mar 22.1 1.1<br> Apr 39.0 1.6<br> May 52.1 2.5<br> Jun 61.4 3.9<br> Jul 66.7 3.6<br> Aug 63.7 3.1<br> Sep 53.4 3.1<br> Oct 42.4 2.0<br> Nov 24.9 1.1<br>                        Dec 7.2 0.8 ;<br><br> end;
                    </p>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleProjectCPM" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="projectCPM" class="modal-body modal-body-example">
                    /* # Project Management with the Critical Path Method<br> The Critical Path Method is a technique for calculating the shortest time span needed to complete a series of tasks. The tasks are represented by nodes, each labelled with the
                    duration. The precedence order of the task is given by a set of arcs.<br> Here we demonstrate the representation and calculation of the critical path. Decision variables are introduced for<br><br> * Earliest Start<br> * Earliest Finish<br>                    * Latest Start<br> * Latest Finish<br> * Slack = Earliest Finish - Earliest Start = Latest Finish - Earliest Finish<br><br> Tasks on the Critical Path have zero slack.<br> */
                    <br><br> set TASKS;<br> set ARCS within {TASKS cross TASKS};<br><br> /* Parameters are the durations for each task */<br> param dur{TASKS} >= 0;<br><br> /* Decision Variables associated with each task*/<br> var Tes{TASKS} >= 0; # Earliest
                    Start
                    <br> var Tef{TASKS} >= 0; # Earliest Finish<br> var Tls{TASKS} >= 0; # Latest Start<br> var Tlf{TASKS} >= 0; # Latest Finish<br> var Tsl{TASKS} >= 0; # Slacks<br><br> /* Global finish time */<br> var Tf >= 0;<br><br> /* Minimize the
                    global finish time and, secondarily, maximize slacks */<br> minimize ProjectFinish : card(TASKS)*Tf - sum {j in TASKS} Tsl[j];<br><br> /* Finish is the least upper bound on the finish time for all tasks */<br> s.t. Efnsh {j in TASKS}
                    : Tef[j]
                    <=T f;<br>
                        s.t. Lfnsh {j in TASKS} : Tlf[j]
                        <=T f;<br><br> /* Relationship between start and finish times for each task */<br> s.t. Estrt {j in TASKS} : Tef[j] = Tes[j] + dur[j];<br> s.t. Lstrt {j in TASKS} : Tlf[j] = Tls[j] + dur[j];<br><br> /* Slacks */<br> s.t. Slack {j in TASKS}
                            : Tsl[j] = Tls[j] - Tes[j];<br><br> /* Task ordering */<br> s.t. Eordr {(i,j) in ARCS} : Tef[i]
                            <=T es[j];<br>
                                s.t. Lordr {(j,k) in ARCS} : Tlf[j]
                                <=T ls[k];<br><br> /* Compute Solution */<br> solve;
                                    <br><br> /* Print Report */<br> printf 'PROJECT LENGTH = %8g\n',Tf;<br><br> /* Critical Tasks are those with zero slack */<br><br> /* Rank-order tasks on the critical path by earliest start time */<br> param r{j in
                                    TASKS : Tsl[j] = 0} := sum{k in TASKS : Tsl[k] = 0}<br> if (Tes[k]
                                    <=T es[j]) then 1;<br><br> printf '\nCRITICAL PATH\n';<br> printf ' TASK DUR Start Finish\n';<br> printf {k in 1..card(TASKS), j in TASKS : Tsl[j]=0 && k==r[j]}<br> '%8s %6g %8g %8g\n', j, dur[j], Tes[j], Tef[j];<br><br> /* Noncritical Tasks
                                        have positive slack */<br><br> /* Rank-order tasks not on the critical path by earliest start time */<br> param s{j in TASKS : Tsl[j] > 0} := sum{k in TASKS : Tsl[k] = 0}<br> if (Tes[k]
                                        <=T es[j]) then 1;<br><br> printf '\nNON-CRITICAL TASKS\n';<br> printf ' Earliest Earliest Latest Latest \n';<br> printf ' TASK DUR Start Finish Start Finish Slack\n';<br> printf {k in 1..card(TASKS), j in TASKS : Tsl[j] > 0 && k==s[j]}<br>                                            '%8s %6g %8g %8g %8g %8g %8g\n', <br> j,dur[j],Tes[j],Tef[j],Tls[j],Tlf[j],Tsl[j];
                                            <br> printf '\n';<br><br> data;

                                            <br><br> /* Stadium Construction Example from Christelle Gueret, Christian Prins, <br> Marc Sevaux, "Applications of Optimization with Xpress-MP," Chapter 5,<br> Dash Optimization, 2000. */ <br><br> param :
                                            TASKS : dur :=<br> T01 2.0<br> T02 16.0<br> T03 9.0<br> T04 8.0<br> T05 10.0<br> T06 6.0<br> T07 2.0<br> T08 2.0<br> T09 9.0<br> T10 5.0<br> T11 3.0<br> T12 2.0<br> T13 1.0<br> T14 7.0<br> T15 4.0<br> T16 3.0<br>                                            T17 9.0<br> T18 1.0 ;<br><br> set ARCS := <br> T01 T02<br> T02 T03<br> T02 T04<br> T02 T14<br> T03 T05<br> T04 T07<br> T04 T10<br> T04 T09<br> T04 T06<br> T04 T15<br> T05 T06<br> T06 T09<br> T06 T11<br> T06
                                            T08
                                            <br> T07 T13<br> T08 T16<br> T09 T12<br> T11 T16<br> T12 T17<br> T14 T16<br> T14 T15<br> T17 T18 ;<br><br> end;

                                            <br>
                                            </b>
                                            </p>
                                            </p>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleJobShop" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="jobShop" class="modal-body modal-body-example">
                    /* # Job Shop Scheduling<br><br> A simple job shop consists of a set of different machines that process jobs. <br> Each job consists of series of tasks that must be completed in specified order<br> on the machines. The problem is to
                    schedule the jobs on the machines to minimize <br> makespan.
                    <br><br> Data consists of two tables. The first table is decomposition of the jobs into<br> a series of tasks. Each task lists a job name, name of the required machine, <br> and task duration. The second table list task pairs where
                    the first task must <br> be completed before the second task can be started. This formulation is quite <br> general, but can also specify situations with no feasible solutions.<br> */
                    <br><br> /* Data Table 1. Tasks consist of Job, Machine, Dur data*/<br> set TASKS dimen 2;<br> param dur{TASKS};<br><br> /* Data Table 2 */<br> set TASKORDER within {TASKS,TASKS};<br><br> /* JOBS and MACHINES are inferred from the
                    data tables*/<br> set JOBS := setof {(j,m) in TASKS} j;<br> set MACHINES := setof {(j,m) in TASKS} m;<br><br> /* Decision variables are start times for tasks, and the makespan */<br> var start{TASKS} >= 0;<br> var makespan >= 0;<br><br>                    /* BigM is set to be bigger than largest possible makespan */<br> param BigM := 1 + sum {(j,m) in TASKS} dur[j,m];<br><br> /* The primary objective is to minimize makespan, with a secondary<br> objective of starting tasks as early
                    as possible */<br> minimize OBJ: BigM*makespan + sum{(j,m) in TASKS} start[j,m];<br><br> /* By definition, all jobs must be completed within the makespan */<br> s.t. A {(j,m) in TASKS}: start[j,m] + dur[j,m]
                    <=m akespan;<br><br> /* Must satisfy any orderings that were given for the tasks. */<br> s.t. B {(k,n,j,m) in TASKORDER}: start[k,n] + dur[k,n]
                        <=s tart[j,m];<br><br> /* Eliminate conflicts if tasks are require the same machine */<br> /* y[i,m,j] = 1 if Job i is scheduled before job j on machine m*/<br> var y{(i,m) in TASKS,(j,m) in TASKS: i
                            < j} binary;<br>
                                s.t. C {(i,m) in TASKS,(j,m) in TASKS: i
                                < j}:<br>
                                    start[i,m] + dur[i,m]
                                    <=s tart[j,m] + BigM*(1-y[i,m,j]);<br>
                                        s.t. D {(i,m) in TASKS,(j,m) in TASKS: i
                                        < j}:<br>
                                            start[j,m] + dur[j,m]
                                            <=s tart[i,m] + BigM*y[i,m,j];<br><br> solve;

                                                <br><br> printf "Makespan = %5.2f\n",makespan;<br><br> /* Post solution, compute finish times for each task to use in report */<br> param finish{(j,m) in TASKS} := start[j,m] + dur[j,m];<br><br> /* Task
                                                Summary Report */<br> printf "\n TASK SUMMARY\n";<br> printf "\n JOB MACHINE Dur Start Finish\n";<br> printf {(i,m) in TASKS} "%8s %8s %5.2f %5.2f %5.2f\n", <br> i, m, dur[i,m], start[i,m], finish[i,m];<br><br>                                                /* Schedule of activities for each job */<br> set M{j in JOBS} := setof {(j,m) in TASKS} m;<br> param r{j in JOBS, m in M[j]} := <br> 1+sum{n in M[j]: start[j,n]
                                                < start[j,m] || start[j,n]==start[j,m] && n < m} 1;<br>
                                                    printf "\n\n JOB SCHEDULES\n";<br> for {j in JOBS} {<br> printf "\n%s:\n",j;<br> printf " MACHINE Start Finish\n";<br> printf {k in 1..card(M[j]), m in M[j]: k==r[j,m]} <br> " %15s %5.2f %5.2f\n",m,
                                                    start[j,m],finish[j,m];
                                                    <br> }
                                                    <br><br> /* Schedule of activities for each machine */<br> set J{m in MACHINES} := setof {(j,m) in TASKS} j;<br> param s{m in MACHINES, j in J[m]} := <br> 1+sum{k in J[m]: start[k,m]
                                                    < start[j,m] || start[k,m]==start[j,m] && k < j} 1;<br>
                                                        printf "\n\n MACHINE SCHEDULES\n";<br> for {m in MACHINES} {<br> printf "\n%s:\n",m;<br> printf " JOB Start Finish\n";<br> printf {k in 1..card(J[m]), j in J[m]: k==s[m,j]} <br> " %15s %5.2f %5.2f\n",j,
                                                        start[j,m],finish[j,m];
                                                        <br> }
                                                        <br><br> data;

                                                        <br><br> /* Job shop data from Christelle Gueret, Christian Prins, Marc Sevaux,<br> "Applications of Optimization with Xpress-MP," Chapter 5, Dash Optimization, 2000. */<br><br> /* Jobs are broken
                                                        down into a list of tasks (j,m), each task described by<br> job name j, machine name m, and duration dur[j,m] */<br><br> param: TASKS: dur :=<br> Paper_1 Blue 45<br> Paper_1 Yellow 10<br> Paper_2
                                                        Blue 20<br> Paper_2 Green 10<br> Paper_2 Yellow 34<br> Paper_3 Blue 12<br> Paper_3 Green 17<br> Paper_3 Yellow 28 ;<br><br> /* List task orderings (k,n,j,m) where task (k,n) must proceed task (j,n)
                                                        */
                                                        <br><br> set TASKORDER :=<br> Paper_1 Blue Paper_1 Yellow<br> Paper_2 Green Paper_2 Blue<br> Paper_2 Blue Paper_2 Yellow<br> Paper_3 Yellow Paper_3 Blue<br> Paper_3 Blue Paper_3 Green ;<br><br> end;

                                                        <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleJesuit" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="Jesuit" class="modal-body modal-body-example">
                    /* # Jesuit Volunteer Corps<br><br> The following problem was formulated by Tomas C. (ND '09) who was working with <br> the Jesuit Volunteer Corp in 2009-2010. Here was his problem:<br><br> > There are 7 of us in the house. We have
                    broken down the chores into 4 <br> > major sections: 1) Kitchen, 2) Bathroom, 3) Common Area, 4) Trash. The <br> > trash is the only task that needs only one person to accomplish, the <br> > other 3 tasks have 2 people assigned to
                    them. Each person needs to rotate<br> > through each task twice and the trash only once. The assignments rotate <br> > each week. Each person needs to have a new partner each week and no <br> > person can have more than one task in
                    a week.<br><br> In the formulation below we require every possible pair to do at least one task <br> together. This is different that requiring a new partner each week, but Tomas<br> said later that this would meet their needs.<br><br>                    This a challenging computation, depending on your computer this may take a few seconds<br> to a few minutes to complete a solution.<br> */
                    <br><br> /* Number of weeks to schedule */<br> param T := 7;<br><br> /* Numeric labels for volunteers facilitate creating non-replicated pairs */<br> set VOLS := 1..7;<br> set TASKS := {'Kitchen', 'Bathroom', 'Commons', 'Trash'};<br>                    set WEEKS := 1..T;<br><br> /* Compute all pairs of volunteers */<br> set PAIRS := setof{u in VOLS, v in VOLS: u
                    < v} (u,v);<br><br> /* x[v,t,w] = 1 if volunteer v is assigned task t in week w */<br> var x{v in VOLS, t in TASKS, w in WEEKS} binary;<br><br> /* p[u,v,t,w] = 1 if volunteers u and v are paired together on t in week w */<br> var p{(u,v) in PAIRS,
                        t in TASKS, w in WEEKS} binary;<br><br> /* The objective will be the number of times anyone has to do the trash */<br> var z integer;<br><br> minimize obj: z;<br><br> /* Each volunteer each week must be assigned one task */<br>                        s.t. fa{v in VOLS, w in WEEKS}: sum {t in TASKS} x[v,t,w] = 1;<br><br> /* Except for Trash, each task each week must be assigned two volunteers */<br> s.t. fb{w in WEEKS}: sum {v in VOLS} x[v,'Trash',w] = 1;<br> s.t. fc{t in TASKS,
                        w in WEEKS : t
                        <> 'Trash'}: sum {v in VOLS} x[v,t,w] = 2;<br><br> /* Each volunteer must cycle through each task twice (except trash) */<br> s.t. fd{t in TASKS, v in VOLS : t
                            <> 'Trash'}: sum {w in WEEKS} x[v,t,w] >= 2;<br><br> /* Minimize number of times anyone has to do trash */<br> s.t. fz{v in VOLS}: sum {w in WEEKS} x[v,'Trash',w]
                                <=z ;<br><br> /* Pair p(u,v,t,w) is 1 if u and v worked together on Week w and Task t */<br> s.t. ga{t in TASKS, w in WEEKS, (u,v) in PAIRS}: p[u,v,t,w]
                                    <=x [u,t,w];<br>
                                        s.t. gb{t in TASKS, w in WEEKS, (u,v) in PAIRS}: p[u,v,t,w]
                                        <=x [v,t,w];<br>
                                            s.t. gc{t in TASKS, w in WEEKS, (u,v) in PAIRS}: <br> p[u,v,t,w] >= x[u,t,w] + x[v,t,w] - 1;<br><br> /* Each possible pair must do at least one task together. */<br> s.t. gd{(u,v) in PAIRS}: sum{t in TASKS,
                                            w in WEEKS} p[u,v,t,w] >= 1;<br><br> solve;

                                            <br>
                                            <br> printf "Volunteer Assignments by Weeks";<br> for {w in WEEKS}{<br> printf "\n\nWeek: %2s\n",w;<br> printf "Volunteer:";<br> printf {v in VOLS} "%3s",v;<br> for {t in TASKS}{<br> printf "\n%9s:",t;<br> printf
                                            {v in VOLS} "%3s", if x[v,t,w]=1 then "X" else "-";<br> }
                                            <br> }
                                            <br><br> printf "\n\n\n Analysis of Volunteer Pairs";<br> for{(u,v) in PAIRS}{<br> printf "\n\nPair: (%s,%s)\n",u,v;<br> printf " Week:";<br> printf {w in WEEKS} "%3s",w;<br> for {t in TASKS}{<br> printf "\n%9s:",t;<br>                                            printf {w in WEEKS} "%3s", if p[u,v,t,w]=1 then "X" else "-";<br> }
                                            <br> }
                                            <br><br> end;

                                            <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTransportationNetwork" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="transportationNetwork" class="modal-body modal-body-example">
                    /* # Transportation Network<br><br> This is a simple model to demonstrate modeling of a transportation <br> network for a system with sources and destinations. The given supply and<br> demand constraints, the objective is to minimize
                    transportation costs. <br> This model demonstrates:<br><br> * Transportation optimization.<br> * Factoring of applications into separate modeling and data sections.<br> * Use of defaults and defining sets in the data section.<br> */
                    <br><br> /* Model Section */<br><br> set SOURCES;<br> set CUSTOMERS;<br><br> param Demand {CUSTOMERS} >= 0;<br> param Supply {SOURCES} >= 0;<br> param Tcost {CUSTOMERS, SOURCES} default 1000;<br><br> var x {CUSTOMERS, SOURCES} >= 0;<br><br>                    /* Minimize total shipping costs */<br> minimize Cost: sum{c in CUSTOMERS, s in SOURCES} Tcost[c,s]*x[c,s];<br><br> /* Total shipped from each source must be less than source capacity */<br> s.t. SRC {s in SOURCES}: sum {c in CUSTOMERS}
                    x[c,s]
                    <=S upply[s];<br><br> /* Total received must equal customer demand */<br> s.t. DST {c in CUSTOMERS}: sum {s in SOURCES} x[c,s] = Demand[c];<br><br> solve;

                        <br><br> data;

                        <br> /* <br> Problem Data from Chapter 5 of Johannes Bisschop, "AIMMS Optimization Modeling",<br> Paragon Decision Sciences, 1999. The following data details supply, demand, and<br> shipping costs among a set of 8 European cities<br>                        */
                        <br><br> param: CUSTOMERS: Demand :=<br> Lon 125 # London<br> Ber 175 # Berlin<br> Maa 225 # Maastricht<br> Ams 250 # Amsterdam<br> Utr 225 # Utrecht<br> Hag 200 ; # The Hague<br><br> param: SOURCES: Supply :=<br> Arn 550 # Arnhem<br>                        Gou 650 ; # Gouda<br><br> param Tcost : Arn Gou :=<br> Lon . 2.5<br> Ber 2.5 .<br> Maa 1.6 2.0<br> Ams 1.4 1.0<br> Utr 0.8 1.0<br> Hag 1.4 0.8 ;<br><br> end;
                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleStockCutting" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="stockCutting" class="modal-body modal-body-example">
                    /* # Stock Cutting<br><br> The stock cutting problem is to minimize the waste associated with cutting up stock<br> materials to produce a set of products. Examples of the one dimensional problem include<br> cutting lengths of steel
                    bar into a set of products, cutting wide paper rolls into<br> smaller ones, and cutting dimensioned lumber to meet the production needs of furniture<br> shops.
                    <br><br> In large scale applications the stock cutting problem begins with a base set of cutting<br> patterns. Each cutting pattern breaks a piece of stock into a set of products. The base<br> calculation is to find a mix of cutting
                    patterns to meet product requirements. A<br> secondary problem is solved to find additional cutting patterns with the potential to<br> reduce costs. The solution then proceeds iteratively with new patterns are generated 'on<br> the
                    fly' coupled with a branch and bound search to find an optimal solution. This<br> approach is called 'column generation.'<br><br> As demonstrated below, for small scale problems the stock cutting problem can be <br> formulated as an
                    assignment of product pieces to stock pieces. For this example the data <br> consists of a list of product types, lengths and demand. The example incorporates <br> multiple types of raw materials. The objective is to maximize the number
                    of pieces of <br> stock material that are left uncut.<br><br> An aspect of this problem is the high degree of solution symmetry. The number of <br> equivalent solutions is a combinatorial function of the number of identical pieces
                    of raw <br> of materials. In these cases a solver may quickly find a solution but then need to search <br> many equivalent solutions to verify optimality. This example uses a weighted objective to <br> separate otherwise equivalent
                    solutions.
                    <br><br> To repeat, this approach will not work for larger problems due to the excessive number of <br> binary variables required and high degree of solution symmetry. Consult the <br>
                    <a href="https://code.google.com/p/cspsol/">cspsol project</a> for a solution method using <br> column generation and glpk api.<br> */
                    <br><br> # Products<br> set PRODUCTS;<br> param pLength{PRODUCTS};<br> param demand{PRODUCTS};<br><br> # Raw Materials<br> set RAWMATERIALS;<br> param rLength{RAWMATERIALS};<br> param avail{RAWMATERIALS};<br><br> # Big M should be
                    greater than the length of any stock piece<br> param bigM;<br> check {r in RAWMATERIALS} : bigM > rLength[r];<br><br> # Create indexed sets enumerating all production pieces<br> set Q{p in PRODUCTS} := 1..demand[p] ;<br><br> # Create
                    indexed sets enumerating all raw material pieces<br> set S{r in RAWMATERIALS} := 1..avail[r];<br><br> # y[p,q,r,s] = 1 assigns (product p, piece q) to (raw material r, piece s)<br> var y{p in PRODUCTS, q in Q[p], r in RAWMATERIALS,
                    s in S[r]} binary;<br><br> # u[r,s] = 1 indicates use of (raw material r, piece s)<br> var u{r in RAWMATERIALS, s in S[r]} binary;<br><br> # w[r,s] is the remainder left over from (raw material r, piece s)<br> var w{r in RAWMATERIALS,
                    s in S[r]} >= 0;<br><br> # Assign product (p,q) only once to the set of all raw materials (r,s)<br> s.t. A{p in PRODUCTS, q in Q[p]} : sum{r in RAWMATERIALS, s in S[r]} y[p,q,r,s] = 1;<br><br> # Cut enough pieces to exactly meet the
                    demand for each product<br> s.t. B{p in PRODUCTS} : sum{q in Q[p], r in RAWMATERIALS, s in S[r]} y[p,q,r,s] = demand[p];<br><br> # Do not exceed the length each piece of raw material<br> s.t. C{r in RAWMATERIALS, s in S[r]} : <br>                    sum{p in PRODUCTS, q in Q[p]} pLength[p]*y[p,q,r,s] + w[r,s] = rLength[r];<br><br> # Determine if a piece (r,s) of raw material is used.<br> s.t. D{r in RAWMATERIALS, s in S[r]} : bigM*u[r,s] >= sum{p in PRODUCTS, q in Q[p]} y[p,q,r,s];<br><br>                    minimize Pieces : sum{r in RAWMATERIALS, s in S[r]} rLength[r]*s*u[r,s];<br><br> solve;

                    <br><br> table products {p in PRODUCTS} OUT "JSON" "Products" "Table" : <br> p~Product, pLength[p]~Length, demand[p]~Demand;<br><br> table rawmaterials {r in RAWMATERIALS} OUT "JSON" "Raw Materials" "Table" : <br> r~Raw_Materials,
                    rLength[r]~Length, avail[r]~Available;<br><br> printf "Cutting Plan\n";<br> for {r in RAWMATERIALS} : {<br> printf " Raw Material %s \n", r;<br> for {s in S[r]} : {<br> printf " Piece %s-%d : Remainder = %5.2f : Cut product pieces
                    ", r,s, w[r,s];<br> for {p in PRODUCTS} : {<br> for {q in Q[p] : y[p,q,r,s]} : {<br> printf "%s-%d ", p, q;<br> }
                    <br> }
                    <br> printf "\n";<br> }
                    <br> printf "\n";<br> }
                    <br><br> printf "Production Plan\n";<br> for {p in PRODUCTS} : {<br> printf " Product %s \n", p;<br> for {q in Q[p]} : {<br> printf " Piece %s-%d : Cut from stock piece ", p, q;<br> for {r in RAWMATERIALS} : {<br> for {s in S[r] :
                    y[p,q,r,s]} : {<br> printf "%s-%d ", r, s;<br> }
                    <br> }
                    <br> printf "\n";<br> }
                    <br> printf "\n";<br> }
                    <br><br> data;

                    <br><br> param bigM := 20;<br><br> param: PRODUCTS: pLength demand :=<br> '7m' 7 3<br> '6m' 6 2<br> '4m' 4 6<br> '3m' 3 1 ;<br> param: RAWMATERIALS: rLength avail :=<br> '15m' 15 3<br> '10m' 10 3 ;<br>
                    <br> end;
                    <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTableSeating" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="tableSeating" class="modal-body modal-body-example">
                    /* # Table Seating<br><br> Problem from the lp_solve listserv, January 12, 2013<br><br> > I am trying write an integer program to solve the following problem. There are 3n<br> > people, who are denoted {a,b,c,...}. There are n tables
                    and 3 people must sit at <br> > each table. There is a value associated with each pair sitting at the same table.<br> > Person a and person b sitting together is represented by a binary variable<br> > a_b and the value of them sitting
                    together is vab.<br><br> > I want find an allocation of people to tables that maximizes the sum of these values,<br> > that is max:+vab*a_b+vac*a_c+vad*a_d+....<br><br> Be careful. The computational effort required for this prolbem
                    grows
                    <br> quickly with N and TABLE_SIZE. Until html 5 worker threads are implemented,<br> this may lock up your browser during the lengthy solution.<br> */
                    <br><br> param N_TABLES := 4;<br> param TABLE_SIZE := 3;<br><br> set TABLES := 1..N_TABLES;<br> set PEOPLE := 1..TABLE_SIZE*N_TABLES;<br> set PAIRS := {p in PEOPLE, q in PEOPLE : q > p};<br><br> var x{PEOPLE,TABLES} binary;<br> var
                    y{PAIRS} binary;<br><br> /* Assignment Constraints */<br> s.t. TablesAreFull{t in TABLES}: sum{p in PEOPLE} x[p,t] = 3;<br> s.t. SOS {p in PEOPLE}: sum{t in TABLES} x[p,t] = 1;<br><br> /* Who is sitting with whom */<br> s.t. W1 {t
                    in TABLES, (p,q) in PAIRS}: y[p,q] >= x[p,t] + x[q,t] - 1;<br> s.t. W2 {p in PEOPLE}: <br> (sum{q in 1..(p-1)} y[q,p]) + (sum{q in (p+1)..card(PEOPLE)} y[p,q])<br> = TABLE_SIZE - 1;<br><br> maximize obj: sum{(p,q) in PAIRS} y[p,q];<br><br>                    solve;

                    <br> printf "Table Assignments\n";<br> printf " ";<br> printf {p in PEOPLE}: " %2d", p;<br> printf "\n";<br> for {t in TABLES}: {<br> printf "Table(%d): ", t;<br> printf {p in PEOPLE}: " %d", x[p,t];<br> printf "\n";<br> }
                    <br><br> printf "\nPairings\n";<br> for {t in TABLES} : {<br> printf "Table %d : ",t;<br> printf {(p,q) in PAIRS : y[p,q] = 1 && x[p,t] = 1}: " (%2d,%2d) ",p,q;<br> printf "\n";<br> }
                    <br><br> end;

                    <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTSPTW" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="tsptw" class="modal-body modal-body-example">
                    /* # Traveling Salesman Problem with Time Windows */ <br>
                    <br> param start symbolic;<br> param finish symbolic, != start;<br> param maxspeed > 0;<br> param minspeed > 0,
                    <=m axspeed;<br>
                        <br> set PLACES;<br> param lat{PLACES};<br> param lng{PLACES};<br> param S1{PLACES};<br> param S2{p in PLACES} >= S1[p];<br>
                        <br> # compute great circle distances and minimum travel times<br> param d2r := 3.1415926/180;<br> param alpha{a in PLACES, b in PLACES} := sin(d2r*(lat[a]-lat[b])/2)**2 <br> + cos(d2r*lat[a])*cos(d2r*lat[b])*sin(d2r*(lng[a]-lng[b])/2)**2;<br>                        param gcdist{a in PLACES, b in PLACES} := 2*6371*atan(sqrt(alpha[a,b]),sqrt(1-alpha[a,b]));<br>
                        <br> # Path constraints<br> var x{PLACES, PLACES} binary;<br>
                        <br> # must leave from all nodes except the finish node<br> s.t. lv1 {a in PLACES : a != finish}: sum{b in PLACES} x[a,b] = 1;<br> s.t. lv2 : sum{b in PLACES} x[finish,b] = 0;<br>
                        <br> # must arrive at all places except the start node<br> s.t. ar1 {a in PLACES : a != start}: sum{b in PLACES} x[b,a] = 1;<br> s.t. ar2 : sum{b in PLACES} x[b,start] = 0;<br>
                        <br> # subtour elimination using an idea from Andrew O. Makhorin<br> var y{PLACES, PLACES} >= 0, integer;<br> s.t. capbnd {a in PLACES, b in PLACES} : y[a,b]
                        <=( card(PLACES)-1)*x[a,b];<br>
                            s.t. capcon {a in PLACES} : sum{b in PLACES} y[b,a] <br> + (if a=start then card(PLACES)) = 1 + sum{b in PLACES} y[a,b];<br>
                            <br> # Time Constraints<br> param bigM := 50;<br> var tar{PLACES}; # arrival<br> var tlv{PLACES}; # departure<br> var tea{PLACES} >= 0; # early arrival (arrival before the designated time window)<br> var tla{PLACES} >= 0; #
                            late arrival (arrival after the designated time window)<br> var ted{PLACES} >= 0; # early departure (departure before the designated time window)<br> var tld{PLACES} >= 0; # late departure (departure after the designated time
                            window)
                            <br>
                            <br> s.t. t0 {a in PLACES} : tlv[a] >= tar[a]; <br> s.t. t1 {a in PLACES, b in PLACES} : <br> tar[b] >= tlv[a] + gcdist[a,b]/maxspeed - bigM*(1-x[a,b]);<br> s.t. t2 {a in PLACES, b in PLACES} : <br> tar[b]
                            <=t lv[a] + gcdist[a,b]/minspeed + bigM*(1-x[a,b]);<br>
                                s.t. t3 {a in PLACES : a != start } : tea[a] >= S1[a] - tar[a]; # early arrival<br> s.t. t4 {a in PLACES : a != start } : tla[a] >= tar[a] - S2[a]; # late arrival<br> s.t. t5 {a in PLACES : a != finish} : ted[a] >= S1[a]
                                - tlv[a]; # early departure<br> s.t. t6 {a in PLACES : a != finish} : tld[a] >= tlv[a] - S2[a]; # late departure<br>
                                <br> # the objective is weighted sum of average and maximum time window excursions<br> var tmax >= 0;<br> s.t. o1 {a in PLACES} : tea[a]
                                <=t max;<br>
                                    s.t. o2 {a in PLACES} : tla[a]
                                    <=t max;<br>
                                        s.t. o3 {a in PLACES} : ted[a]
                                        <=t max;<br>
                                            s.t. o4 {a in PLACES} : tld[a]
                                            <=t max;<br>
                                                <br> minimize obj: sum{a in PLACES} (1*tea[a] + 2*tla[a] + 2*ted[a] + 1*tld[a]) + 2*tmax;<br>
                                                <br> solve;
                                                <br>
                                                <br> printf "%6s %3s %6s %3s %6s %6s %6s %6s %7s %5s %6s\n", <br> 'Depart','','Arrive','','EDep','LDep','EArr','LArr','Dist','Time','Speed';
                                                <br>
                                                <br> for {k in card(PLACES)-1..0 by -1} {<br> printf {a in PLACES, b in PLACES : (y[a,b]=k) && (x[a,b]=1)}<br> "%-3s %7.2f %-3s %7.2f %6.2f%1s %5.2f%1s %5.2f%1s %5.2f%1s %6.1f %5.2f %6.1f\n", <br> a, tlv[a],
                                                b, tar[b], <br> ted[a], if (ted[a]>0) then '*' else ' ',<br> tld[a], if (tld[a]>0) then '*' else ' ',<br> tea[b], if (tea[b]>0) then '*' else ' ',<br> tla[b], if (tla[b]>0) then '*' else ' ',<br> gcdist[a,b],
                                                (tar[b]-tlv[a]), gcdist[a,b]/(tar[b]-tlv[a]);<br> }
                                                <br>
                                                <br> data;
                                                <br>
                                                <br> param start := 'ATL';<br> param finish := 'ORD';<br> param maxspeed := 800;<br> param minspeed := 600;<br>
                                                <br> param : PLACES : lat lng S1 S2 :=<br> ATL 33.6366995 -84.4278639 8.0 24.0<br> BOS 42.3629722 -71.0064167 8.0 9.0<br> DEN 39.8616667 -104.6731667 12.0 15.0<br> DFW 32.8968281 -97.0379958 12.0 13.0<br>                                                JFK 40.6397511 -73.7789256 18.0 20.0<br> LAX 33.9424955 -118.4080684 12.0 16.0<br> ORD 41.9816486 -87.9066714 20.0 24.0<br> STL 38.7486972 -90.3700289 11.0 13.0<br> ; <br>
                                                <br> end;
                                                <br>

                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleVRP" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="vrp" class="modal-body modal-body-example"><br> /* # Vehicle Routing Problem
                    <br> A set of airplanes are initially distributed among a set of<br> starting locations. They are to be assigned routes to collectively<br> visit a specified set of customers then return the the planes to<br> designated finishing locations.
                    The optimization objective is to<br> minimize the total great circle distance.<br>
                    <br> The data consists of a set of locations with latitude and longitude<br> information, a list of customers and their respective locations, and<br> a set of aircraft and their starting and finishing locations. The<br> aircraft must
                    start and finish at different locations (if needed,<br> dummy locations with the same latitude and longitude can be <br> included in the list of locations).<br> */
                    <br>
                    <br> # Jeffrey Kantor<br> # March, 2013<br>
                    <br> # DATA SETS (IN THE DATA SECTION)<br>
                    <br> # CUSTOMERS is a set of (name,location) pairs <br> set CUSTOMERS dimen 2;<br>
                    <br> # PLANES is a set of (name, start_location, finish_location) triples<br> set PLANES dimen 3;<br>
                    <br> # set of locations<br> set LOCATIONS;<br> param lat{LOCATIONS};<br> param lng{LOCATIONS};<br>
                    <br> # DATA PREPROCESSING<br>
                    <br> # create a set of planes<br> set P := setof {(p,sLoc,fLoc) in PLANES} p;<br>
                    <br> # create a set of all nodes as (name, location) pairs<br> set START := setof {(p,sLoc,fLoc) in PLANES} (p,sLoc);<br> set FINISH := setof {(p,sLoc,fLoc) in PLANES} (p,fLoc);<br> set N := CUSTOMERS union (START union FINISH);<br>
                    <br> # compute great circle distances [km] between locations from latitude,<br> # longitude data using Haversine formula<br> param d2r := 3.1415926/180;<br> param alpha{a in LOCATIONS, b in LOCATIONS} := sin(d2r*(lat[a]-lat[b])/2)**2
                    <br> + cos(d2r*lat[a])*cos(d2r*lat[b])*sin(d2r*(lng[a]-lng[b])/2)**2;<br> param gcdist{a in LOCATIONS, b in LOCATIONS} := <br> 2*6371*atan( sqrt(alpha[a,b]), sqrt(1-alpha[a,b]) );<br>
                    <br> # DECISION VARIABLES<br>
                    <br> # x[p,a,aLoc,b,bLoc] = 1 if plane p flies from (a,aLoc) to (b,bLoc)<br> var x{P, N, N} binary;<br>
                    <br> # START AND FINISH CONSTRAINTS<br>
                    <br> # no planes arrive at the start nodes<br> s.t. sf1 {p in P, (a,aLoc) in N, (b,bLoc) in START} : x[p,a,aLoc,b,bLoc] = 0;<br>
                    <br> # no planes leave the finish nodes<br> s.t. sf2 {p in P, (a,aLoc) in FINISH, (b,bLoc) in N} : x[p,a,aLoc,b,bLoc] = 0;<br>
                    <br> # planes must leave from their own start nodes<br> s.t. sf3 {p in P, (a,aLoc) in START, (b,bLoc) in N : p != a} : x[p,a,aLoc,b,bLoc] = <br>0;
                    <br> # planes must return to their own finish nodes<br> s.t. sf4 {p in P, (a,aLoc) in N, (b,bLoc) in FINISH : p != b} : x[p,a,aLoc,b,bLoc] =<br> 0;
                    <br> # NETWORK CONSTRAINTS<br>
                    <br> # one plane arrives at each customer and finish node<br> s.t. nw1 {(b,bLoc) in (CUSTOMERS union FINISH)} : <br> sum {p in P, (a,aLoc) in (CUSTOMERS union START)} x[p,a,aLoc,b,bLoc] = 1;<br>
                    <br> # one plane leaves each start and customer node<br> s.t. nw2 {(a,aLoc) in (START union CUSTOMERS)} :<br> sum {p in P, (b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc] = 1;<br>
                    <br> # planes entering a customer node must leave the same node<br> s.t. nw3 {p in P, (a,aLoc) in CUSTOMERS} : <br> sum {(b,bLoc) in (CUSTOMERS union START)} x[p,b,bLoc,a,aLoc]<br> = sum {(b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc];<br>
                    <br> # no self loops<br> s.t. nw4 {p in P, (a,aLoc) in N, (b,bLoc) in N : (a=b) && (aLoc=bLoc)} :<br> x[p,a,aLoc,b,bLoc] = 0;<br>
                    <br> # SUBTOUR ELIMINATION CONSTRAINTS<br>
                    <br> var y{P,N,N} integer, >= 0;<br>
                    <br> # route capacity<br> s.t. sb1 {p in P, (a,aLoc) in N, (b,bLoc) in N} : <br> y[p,a,aLoc,b,bLoc]
                    <=c ard(CUSTOMERS)*x[p,a,aLoc,b,bLoc];<br>
                        <br> # allocate tokens to links from the start nodes<br> s.t. sb2 : sum {p in P, (a,aLoc) in START, (b,bLoc) in N } y[p,a,aLoc,b,bLoc] <br> = card(CUSTOMERS);<br>
                        <br> # decrease tokens for each step on a path<br> s.t. sb3 {(a,aLoc) in CUSTOMERS} : <br> sum{p in P, (b,bLoc) in (CUSTOMERS union START)} y[p,b,bLoc,a,aLoc] <br> = 1 + sum{p in P, (b,bLoc) in (CUSTOMERS union FINISH)} y[p,a,aLoc,b,bLoc];<br>
                        <br> # OBJECTIVE<br>
                        <br> # route distance for each plane<br> var routeDistance{P} >= 0;<br> s.t. ob1 {p in P} : routeDistance[p] <br> = sum{(a,aLoc) in N, (b,bLoc) in N} gcdist[aLoc,bLoc]*x[p,a,aLoc,b,bLoc];<br>
                        <br> # number of legs on the route for each plane<br> var routeLegs{P} >= 0;<br> s.t. ob2 {p in P} : routeLegs[p] = sum{(a,aLoc) in START, (b,bLoc) in N} y[p,a,aLoc,<br>b,bLoc];
                        <br> # maximum distance on the route of any plane<br> var maxDistance >= 0;<br> s.t. ob3 {p in P} : routeDistance[p]
                        <=m axDistance;<br>
                            <br> # maximum number of legs on the route of any plane<br> var maxLegs >= 0;<br> s.t. ob4 {p in P} : routeLegs[p]
                            <=m axLegs;<br>
                                <br> # pick an objective. Here we minimize total route distance.<br> minimize distance : sum{p in P} routeDistance[p];<br>
                                <br> solve;
                                <br>
                                <br> # OUTPUT POST-PROCESSING<br>
                                <br> for {p in P} {<br> printf "\nRouting for %s\n-------------------\n", p;<br> printf "%-20s %-20s %10s \n", 'Depart','Arrive','Dist.';<br> for {k in routeLegs[p]..0 by -1} {<br> printf {(a,aLoc) in N, (b,bLoc) in N :
                                <br> (x[p,a,aLoc,b,bLoc] = 1) && (y[p,a,aLoc,b,bLoc]=k)} <br> "%-12s %-5s %-12s %-5s %10.1f km\n",a,aLoc,b,bLoc,gcdist[aLoc,bLoc];<br> }
                                <br> printf "%42s %13s\n", '', '---------';<br> printf "%42s %10.1f km\n\n", 'GC Distance Traveled:', routeDistance[p];<br> }
                                <br>
                                <br> # DATA SECTION<br>
                                <br> data;
                                <br>
                                <br> set CUSTOMERS := <br> ( 'Atlanta', ATL )<br> ( 'Boston', BOS )<br> ( 'Denver', DEN )<br> ( 'Dallas', DFW )<br> ( 'New York', JFK )<br> ( 'Los Angeles', LAX )<br> ( 'Chicago', ORD )<br> ( 'St. Louis', STL ) <br> ;
                                <br>
                                <br> set PLANES :=<br> ( 'Plane 1', ORD, ORD_) # use a duplicate location to return place to ORD<br> ( 'Plane 2', DFW, DRW_) # use a duplicate location to return plane to DFW<br> ;
                                <br>
                                <br> param : LOCATIONS : lat lng :=<br> ATL 33.6366995 -84.4278639<br> BOS 42.3629722 -71.0064167<br> DEN 39.8616667 -104.6731667<br> DFW 32.8968281 -97.0379958<br> DRW_ 32.8968281 -97.0379958 # duplicate PLANES<br> JFK
                                40.6397511 -73.7789256<br> LAX 33.9424955 -118.4080684<br> ORD 41.9816486 -87.9066714<br> ORD_ 41.9816486 -87.9066714 # duplicate PLANES<br> STL 38.7486972 -90.3700289<br> ; <br>
                                <br> end;
                                <br>
                                <br> <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleVRPTW" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="vrptw" class="modal-body modal-body-example">
                    /* # Vehicle Routing Problem with Time Windows <br>
                    <br> A set of airplanes are initially distributed among a set of<br> starting locations. They are to be assigned routes to collectively<br> visit a specified set of customers then return the the planes to<br> designated finishing locations
                    within designated time windows.<br>
                    <br> The data consists of a set of locations with latitude and longitude<br> information, a list of customers and their respective locations, and<br> a set of aircraft and their starting and finishing locations, and <br> the start
                    and of associated time windows. The aircraft must start <br> and finish at different locations (if needed, dummy locations with<br> the same latitude and longitude can be included in the list of <br> locations). Plane speed is constrained
                    to between upper and lower<br> bounds.
                    <br>
                    <br> The time windows are implemented as 'soft' constraints. Additional<br> decision variables are<br>
                    <br> * tar[name,loc] arrival time at (name,loc) <br> * tlv[name,loc] departure time from (name,loc)<br> * tea[name,loc] >= 0 for arrival before the time window<br> * tla[name,loc] >= 0 for arrival after the time window<br> * ted[name,loc]
                    >= 0 for departure before the time window<br> * tld[name,loc] >= 0 for departure after the time window<br>
                    <br> A weighted some of tea, tla, ted, and tld constitutes a time <br> penalty which is zero if there is a feasible solution.<br>
                    <br> The objective function is weighted sum of the time penalty and<br> total route distance.<br>
                    <br> Jeffrey Kantor<br> March, 2013<br> */
                    <br>
                    <br> # DATA SETS (TO BE GIVEN IN THE DATA SECTION)<br>
                    <br> param maxspeed > 0;<br> param minspeed > 0,
                    <=m axspeed;<br>
                        <br> # CUSTOMERS is a set of (name,location) pairs <br> set CUSTOMERS dimen 2;<br> param T1{CUSTOMERS};<br> param T2{(name,loc) in CUSTOMERS} >= T1[name,loc];<br>
                        <br> # PLANES is a set of (name, start_location, finish_location) triples<br> set PLANES dimen 3;<br> param S1{PLANES};<br> param S2{(p,sLoc,fLoc) in PLANES} >= S1[p,sLoc,fLoc];<br> param F1{PLANES};<br> param F2{(p,sLoc,fLoc)
                        in PLANES} >= F1[p,sLoc,fLoc];<br>
                        <br> # set of locations<br> set LOCATIONS;<br> param lat{LOCATIONS};<br> param lng{LOCATIONS};<br>
                        <br> # DATA PREPROCESSING<br>
                        <br> # set of planes<br> set P := setof {(p,sLoc,fLoc) in PLANES} p;<br>
                        <br> # compute START as (plane,startlocation) pairs with time windows<br> set START := setof {(p,sLoc,fLoc) in PLANES} (p,sLoc);<br> param TS1{(p,sLoc) in START} := <br> max{ (q,tLoc,fLoc) in PLANES : (p=q) && (sLoc=tLoc) } S1[p,sLoc,fLoc];<br>                        param TS2{(p,sLoc) in START} := <br> min{ (q,tLoc,fLoc) in PLANES : (p=q) && (sLoc=tLoc) } S2[p,sLoc,fLoc];<br>
                        <br> # compute FINISH as (plane,finishlocation) pairs with time windows<br> set FINISH := setof {(p,sLoc,fLoc) in PLANES} (p,fLoc);<br> param TF1{(p,fLoc) in FINISH} := <br> max{ (q,sLoc,gLoc) in PLANES : (p=q) && (fLoc=gLoc) }
                        F1[p,sLoc,fLoc];
                        <br> param TF2{(p,fLoc) in FINISH} := <br> min{ (q,sLoc,gLoc) in PLANES : (p=q) && (fLoc=gLoc) } F2[p,sLoc,fLoc];<br>
                        <br> # create a complete of nodes as (name, location) pairs<br> set N := CUSTOMERS union (START union FINISH);<br>
                        <br> # great circle distances between locations<br> param d2r := 3.1415926/180;<br> param alpha{a in LOCATIONS, b in LOCATIONS} := sin(d2r*(lat[a]-lat[b])/2)**2 <br> + cos(d2r*lat[a])*cos(d2r*lat[b])*sin(d2r*(lng[a]-lng[b])/2)**2;<br>                        param gcdist{a in LOCATIONS, b in LOCATIONS} := <br> 2*6371*atan( sqrt(alpha[a,b]), sqrt(1-alpha[a,b]) );<br>
                        <br> # DECISION VARIABLES<br>
                        <br> # x[p,a,aLoc,b,bLoc] = 1 if plane p flies from (a,aLoc) to (b,bLoc)<br> var x{P, N, N} binary;<br>
                        <br> # START AND FINISH CONSTRAINTS<br>
                        <br> # no planes arrive at the start nodes<br> s.t. sf1 {p in P, (a,aLoc) in N, (b,bLoc) in START} : <br> x[p,a,aLoc,b,bLoc] = 0;<br>
                        <br> # no planes leave the finish nodes<br> s.t. sf2 {p in P, (a,aLoc) in FINISH, (b,bLoc) in N} : <br> x[p,a,aLoc,b,bLoc] = 0;<br>
                        <br> # planes must leave from their own start nodes<br> s.t. sf3 {p in P, (a,aLoc) in START, (b,bLoc) in N : p != a} : <br> x[p,a,aLoc,b,bLoc] = 0;<br>
                        <br> # planes must return to their own finish nodes<br> s.t. sf4 {p in P, (a,aLoc) in N, (b,bLoc) in FINISH : p != b} : <br> x[p,a,aLoc,b,bLoc] = 0;<br>
                        <br> # NETWORK CONSTRAINTS<br>
                        <br> # one plane arrives at each customer and finish node<br> s.t. nw1 {(b,bLoc) in (CUSTOMERS union FINISH)} : <br> sum {p in P, (a,aLoc) in (CUSTOMERS union START)} x[p,a,aLoc,b,bLoc] = 1;<br>
                        <br> # one plane leaves each start and customer node<br> s.t. nw2 {(a,aLoc) in (START union CUSTOMERS)} :<br> sum {p in P, (b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc] = 1;<br>
                        <br> # planes entering a customer node must leave the same node<br> s.t. nw3 {p in P, (a,aLoc) in CUSTOMERS} : <br> sum {(b,bLoc) in (CUSTOMERS union START)} x[p,b,bLoc,a,aLoc]<br> = sum {(b,bLoc) in (CUSTOMERS union FINISH)} x[p,a,aLoc,b,bLoc];<br>
                        <br> # no self loops<br> s.t. nw4 {p in P, (a,aLoc) in N, (b,bLoc) in N : (a=b) && (aLoc=bLoc)} :<br> x[p,a,aLoc,b,bLoc] = 0;<br>
                        <br> # SUBTOUR ELIMINATION CONSTRAINTS<br>
                        <br> var y{P,N,N} >= 0;<br>
                        <br> # route capacity<br> s.t. sb1 {p in P, (a,aLoc) in N, (b,bLoc) in N} : <br> y[p,a,aLoc,b,bLoc]
                        <=c ard(CUSTOMERS)*x[p,a,aLoc,b,bLoc];<br>
                            <br> # allocate tokens to links from the start nodes<br> s.t. sb2 : sum {p in P, (a,aLoc) in START, (b,bLoc) in N } y[p,a,aLoc,b,bLoc] <br> = card(CUSTOMERS);<br>
                            <br> # decrease tokens for each step on a path<br> s.t. sb3 {(a,aLoc) in CUSTOMERS} : <br> sum{p in P, (b,bLoc) in (CUSTOMERS union START)} y[p,b,bLoc,a,aLoc] <br> = 1 + sum{p in P, (b,bLoc) in (CUSTOMERS union FINISH)} y[p,a,aLoc,b,bLoc]<br>;
                            <br> # TIME WINDOW CONSTRAINTS<br> param bigM := 50;<br> var tar{N};<br> var tlv{N};<br> var tea{N} >= 0;<br> var tla{N} >= 0;<br> var ted{N} >= 0;<br> var tld{N} >= 0;<br>
                            <br> s.t. t00 {(a,aLoc) in N} : tlv[a,aLoc] >= tar[a,aLoc];<br> s.t. t01 {p in P, (a,aLoc) in N, (b,bLoc) in N} : tar[b,bLoc] >= tlv[a,aLoc] <br> + gcdist[aLoc,bLoc]/maxspeed - bigM*(1-x[p,a,aLoc,b,bLoc]);<br> s.t. t02 {p in
                            P, (a,aLoc) in N, (b,bLoc) in N} : tar[b,bLoc]
                            <=t lv[a,aLoc] <br>
                                + gcdist[aLoc,bLoc]/minspeed + bigM*(1-x[p,a,aLoc,b,bLoc]);<br> s.t. t03 {(a,aLoc) in CUSTOMERS} : tea[a,aLoc] >= T1[a,aLoc] - tar[a,aLoc];<br> s.t. t04 {(a,aLoc) in FINISH} : tea[a,aLoc] >= TF1[a,aLoc] - tar[a,aLoc];<br>                                s.t. t05 {(a,aLoc) in CUSTOMERS} : tla[a,aLoc] >= tar[a,aLoc] - T2[a,aLoc];<br> s.t. t06 {(a,aLoc) in FINISH} : tla[a,aLoc] >= tar[a,aLoc] - TF2[a,aLoc];<br> s.t. t07 {(a,aLoc) in START} : ted[a,aLoc] >= TS1[a,aLoc] - tlv[a,aLoc];<br>                                s.t. t08 {(a,aLoc) in CUSTOMERS} : ted[a,aLoc] >= T1[a,aLoc] - tlv[a,aLoc];<br> s.t. t09 {(a,aLoc) in START} : tld[a,aLoc] >= tlv[a,aLoc] - TS2[a,aLoc];<br> s.t. t10 {(a,aLoc) in CUSTOMERS} : tld[a,aLoc] >= tlv[a,aLoc]
                                - T2[a,aLoc];<br>
                                <br> # OBJECTIVE<br> # The objective function is a weighted sum of violations of the time window<br> # constraints and the total distance traveled. <br>
                                <br> var routeDistance{P} >= 0;<br> s.t. ob1 {p in P} : routeDistance[p] <br> = sum{(a,aLoc) in N, (b,bLoc) in N} gcdist[aLoc,bLoc]*x[p,a,aLoc,b,bLoc];<br>
                                <br> var totalDistance >= 0;<br> s.t. ob2 : totalDistance = sum{p in P} routeDistance[p];<br>
                                <br> var timePenalty >= 0;<br> s.t. ob3 : timePenalty = <br> sum{(a,aLoc) in N} (tea[a,aLoc] + 2*tla[a,aLoc] + 2*ted[a,aLoc] + tld[a,aLoc])<br>;
                                <br> minimize obj: 5*timePenalty + totalDistance/maxspeed;<br>
                                <br> solve;
                                <br>
                                <br> # OUTPUT POST-PROCESSING<br>
                                <br> param routeTime{p in P} := <br> sum{(a,aLoc) in N, (b,bLoc) in N} (tar[b,bLoc]-tlv[a,aLoc])*x[p,a,aLoc,b,bLoc]<br>;
                                <br> param routeLegs{p in P} :=<br> sum{(a,aLoc) in START, (b,bLoc) in N} y[p,a,aLoc,b,bLoc];<br>
                                <br> for {p in P} {<br> printf "\nRouting for %s\n-------------------\n", p;<br> printf "%-24s %-24s %7s %5s %6s \n", <br> 'Depart','Arrive','Dist.','Time','Speed';
                                <br> for {k in routeLegs[p]..0 by -1} {<br> printf {(a,aLoc) in N, (b,bLoc) in N : <br> (x[p,a,aLoc,b,bLoc] = 1) && (abs(y[p,a,aLoc,b,bLoc]-k)
                                <0.001)} <br>
                                    "%-12s %-4s %5.2f%1s %-12s %-4s %5.2f%1s %7.1f %5.2f %6.1f\n", <br> a, aLoc, tlv[a,aLoc], <br> if (ted[a,aLoc] > 0) then "E" else (if (tld[a,aLoc] > 0) then "L" else" "),<br> b, bLoc, tar[b,bLoc],<br> if (tea[b,bLoc]
                                    > 0) then "E" else (if (tla[b,bLoc] > 0) then "L" else " "),<br> gcdist[aLoc,bLoc], tar[b,bLoc]-tlv[a,aLoc], <br> if (gcdist[aLoc,bLoc] > 0) then gcdist[aLoc,bLoc]/(tar[b,bLoc]-tlv[a,aLoc]) else 0;<br> }
                                    <br> printf "%50s %7s %5s\n", '', '-------','-----';<br> printf "%50s %7.1f %5.2f\n\n", 'Totals:', routeDistance[p], routeTime[p];<br> }
                                    <br>
                                    <br> # DATA SECTION<br>
                                    <br> data;
                                    <br>
                                    <br> param maxspeed := 800;<br> param minspeed := 600;<br>
                                    <br> param : CUSTOMERS : T1 T2 := <br> 'Atlanta' ATL 8.0 24.0<br> 'Boston' BOS 8.0 9.0<br> 'Denver' DEN 12.0 15.0<br> 'Dallas' DFW 12.0 13.0<br> 'New York' JFK 18.0 20.0<br> 'Los Angeles' LAX 12.0 16.0<br> 'Chicago'
                                    ORD 20.0 24.0<br> 'St. Louis' STL 11.0 13.0<br> ;
                                    <br>
                                    <br> param : PLANES : S1 S2 F1 F2 :=<br> 'Plane 1' ORD ORD_ 8.0 24.0 8.0 24.0<br> 'Plane 2' DFW DRW_ 8.0 24.0 8.0 24.0<br> ;
                                    <br>
                                    <br> param : LOCATIONS : lat lng :=<br> ATL 33.6366995 -84.4278639<br> BOS 42.3629722 -71.0064167<br> DEN 39.8616667 -104.6731667<br> DFW 32.8968281 -97.0379958 # start location<br> DRW_ 32.8968281 -97.0379958 # finish
                                    location
                                    <br> JFK 40.6397511 -73.7789256<br> LAX 33.9424955 -118.4080684<br> ORD 41.9816486 -87.9066714 # start location<br> ORD_ 41.9816486 -87.9066714 # finish location<br> STL 38.7486972 -90.3700289<br> ; <br>
                                    <br> end;
                                    <br>

                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleTheNewsvendorProblem" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="theNewsvendorProblem" class="modal-body modal-body-example">
                    /* # The Newsvendor Problem <br>
                    <br> The newsvendor problem is a two stage decision problem with recourse. The <br> vendor needs to decide how much inventory to order today to fulfill an <br> uncertain demand. The data includes the unit cost, price, and salvage value
                    of <br> the product being sold, and a probabilistic forecast of demand. The objective <br> is to maximize expected profit.<br>
                    <br> As shown in lecture, this problem can be solved with a plot, and the solution<br> interpreted in terms of a cumulative probability distribution. The advantage<br> of a MathProg model is that additional constraints or other criteria
                    may be <br> considered, such as risk aversion.<br>
                    <br> There is an extensive literature on the newsvendor problem which has been <br> studied since at least 1888. See <br>
                    <a rel="external" href="http://www.isye.umn.edu/courses/ie5551/additional%20materials/newsvendort.pdf">here</a> for a thorough discussion.<br> */
                    <br>
                    <br> /* Unit Price Data */<br> param r >= 0; # Price<br> param c >= 0; # Cost<br> param w >= 0; # Salvage value<br>
                    <br> /* Price data makes sense only if Price > Cost > Salvage */<br> check: c
                    <=r ;<br>
                        check: w
                        <=c ;<br>
                            <br> /* Probabilistic Demand Forecast */<br> set SCENS; # Scenarios<br> param D{SCENS} >= 0; # Demand<br> param Pr{SCENS} >= 0; # Probability<br>
                            <br> /* Probabilities must sum to one. */<br> check: sum{k in SCENS} Pr[k] = 1;<br>
                            <br> /* Expected Demand */<br> param ExD := sum{k in SCENS} Pr[k]*D[k];<br>
                            <br> /* Lower Bound on Profit: Expected Value of the Mean Solution */<br> param EVM := -c*ExD + sum{k in SCENS} Pr[k]*(r*min(ExD,D[k])+w*max(ExD-D[k],0));<br>
                            <br> /* Upper Bound on Profit: Expected Value with Perfect Information */<br> param EVPI := sum{k in SCENS} Pr[k]*(r-c)*D[k];<br>
                            <br> /* Two Stage Stochastic Programming */<br> var x >= 0; # Stage 1 (Here and Now): Order Quqntity<br> var y{SCENS}>= 0; # Stage 2 (Scenario Dep): Actual Sales<br> var ExProfit; # Expected Profit<br>
                            <br> /* Maximize Expected Profit */<br> maximize OBJ: ExProfit;<br>
                            <br> /* Goods sold are limited by the order quantities and the demand */<br> s.t. PRFT: ExProfit = -c*x + sum{k in SCENS} Pr[k]*(r*y[k] + w*(x-y[k]));<br> s.t. SUPL {k in SCENS}: y[k]
                            <=x ;<br>
                                s.t. DMND {k in SCENS}: y[k]
                                <=D [k];<br>
                                    <br> solve;
                                    <br>
                                    <br> table Table_EVM {k in SCENS} OUT "JSON" "Expected Value for the Mean Scenario" "Table":<br> k~Scenario,
                                    <br> Pr[k]~Probability, <br> D[k]~Demand, <br> ExD~Order, <br> min(ExD,D[k])~Sold,
                                    <br> max(ExD-D[k],0)~Salvage, <br> -c*ExD + r*min(ExD,D[k]) + w*max(ExD-D[k],0)~Profit;<br>
                                    <br> table Table_EVPI {k in SCENS} OUT "JSON" "Expected Value of Perfect Information" "Table":<br> k~Scenario,
                                    <br> Pr[k]~Probability, <br> D[k]~Demand, <br> D[k]~Order, <br> D[k]~Sold,
                                    <br> 0~Salvage, <br> -c*D[k] + r*D[k]~Profit;<br>
                                    <br> table Table_SP {k in SCENS} OUT "JSON" "Expected Value by Stochastic Programming" "Table":<br> k~Scenario,
                                    <br> Pr[k]~Probability, <br> D[k]~Demand, <br> x~Order, <br> y[k]~Sold,
                                    <br> x-y[k]~Salvage, <br> -c*x + r*y[k] + w*(x-y[k])~Profit;<br>
                                    <br> table Summary {k in 1..1} OUT "JSON" "Summary" "Table":<br> EVPI-ExProfit~Value_of_Perfect_Information,
                                    <br> ExProfit - EVM~Value_of_Stochastic_Solution; <br>
                                    <br> printf "EXPECTED VALUE OF THE MEAN SOLUTION\n" >> "EVM";<br> printf "\nSCENARIO PROB DEMAND ORDER SOLD SALVAGE PROFIT\n" >> "EVM";<br> printf {k in SCENS} "%s %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\n",<br> k, Pr[k],
                                    D[k], ExD, min(ExD,D[k]), max(ExD-D[k],0), <br> -c*ExD + r*min(ExD,D[k]) + w*max(ExD-D[k],0) >> "EVM";<br> printf "\n%s %7.2f %7.2f %7.2f %7.2f %7.2f\n",<br> 'MEAN', ExD, ExD, sum{k in SCENS}Pr[k]*min(ExD,D[k]),<br>                                    sum{k in SCENS}Pr[k]*max(ExD-D[k],0),EVM >> "EVM";<br>
                                    <br> printf "EXPECTED VALUE WITH PERFECT INFORMATION\n" >> "EVPI";<br> printf "\nSCENARIO PROB DEMAND ORDER SOLD SALVAGE PROFIT\n" >> "EVPI";<br> printf {k in SCENS} "%s %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\n",<br> k,
                                    Pr[k], D[k], D[k], D[k], 0, -c*D[k] + r*D[k] >> "EVPI";<br> printf "\n%s %7.2f %7.2f %7.2f %7.2f %7.2f\n",<br> 'MEAN', ExD, ExD, ExD,0,EVPI >> "EVPI";<br>
                                    <br> printf "TWO STAGE STOCHASTIC PROGRAMMING\n\n" >> "SP";<br> printf " Order Quantity = %g\n", x >> "SP";<br> printf "Expected Profit = %g\n", ExProfit >> "SP";<br> printf "\nSCENARIO PROB DEMAND ORDER SOLD SALVAGE
                                    PROFIT\n" >> "SP";<br> printf {k in SCENS} "%s %7.2f %7.2f %7.2f %7.2f %7.2f %7.2f\n",<br> k, Pr[k], D[k], x, y[k], x-y[k], -c*x + r*y[k] + w*(x-y[k]) >> "SP";<br> printf "\n%s %7.2f %7.2f %7.2f %7.2f %7.2f\n",<br>                                    'MEAN', ExD, x, sum{k in SCENS}Pr[k]*y[k],<br> sum{k in SCENS}Pr[k]*(x-y[k]),ExProfit >> "SP";<br>
                                    <br> printf " VALUE OF PERFECT INFORMATION = %7.2f\n",EVPI-ExProfit >> "Summary";<br> printf "VALUE OF THE STOCHASTIC SOLUTION = %7.2f\n",ExProfit - EVM >> "Summary"; <br>
                                    <br> data;
                                    <br>
                                    <br> /* Problem Data corresponds to a hypothetical case of selling programs prior <br> to a home football game. */<br>
                                    <br> param r := 10.00; # Unit Price<br> param c := 6.00; # Unit Cost<br> param w := 2.00; # Unit Salvage Value<br>
                                    <br> param: SCENS: Pr D :=<br> HiDmd 0.25 250<br> MiDmd 0.50 125<br> LoDmd 0.25 75 ;<br>
                                    <br> end;
                                    <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleBPMACO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="BPMACO" class="modal-body modal-body-example">
                    /* # Binomial Pricing Model for an American Call Option<br><br> Determines the price of an American call option using a binomial option<br> pricing model. The option price is the minimum value of a portfolio<br> that replicates the
                    option payoff at expiration or at early exercise.<br> */
                    <br>
                    <br> # Asset Model<br> <br> param S0 := 100; # initial price <br> param r := 0.06; # mean return (annualized)<br> param sigma := 0.3; # volatility (annualized)<br>
                    <br> # Bond Price<br> param B0 := 1; # initial value<br> param rf := 0.05; # risk-free interest rate<br>
                    <br> # Option<br> param Kstrike := 100; # strike price<br> param Tf := 0.5; # time to expiration (years)<br>
                    <br> # Construct a recombining binomial tree<br> param nPeriods := 10;<br> set PERIODS := {0..nPeriods};<br> set STATES {p in PERIODS} := {0..p};<br> param u := exp(sigma*sqrt(Tf/nPeriods));<br> param d := 1/u;<br> param pr := (exp(r*Tf/nPeriods)-d)/(u-d);<br>
                    <br> param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;<br> param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));<br>
                    <br> # Replicating Portfolio<br> var C{p in PERIODS, s in STATES[p]};<br> var x{p in PERIODS, s in STATES[p]};<br> var y{p in PERIODS, s in STATES[p]};<br>
                    <br> portfolio {p in PERIODS, s in STATES[p]}: C[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];<br>
                    <br> # Self financing constraints<br> do {p in PERIODS, s in STATES[p] : p
                    < nPeriods}: <br>
                        x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= C[p+1,s];<br> up {p in PERIODS, s in STATES[p] : p
                        < nPeriods}: <br>
                            x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= C[p+1,s+1];<br>
                            <br> # Finance early exercise option<br> edo{p in PERIODS, s in STATES[p] : p
                            < nPeriods}: <br>
                                x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= S[p+1,s] - Kstrike;<br> eup{p in PERIODS, s in STATES[p] : p
                                < nPeriods}: <br>
                                    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= S[p+1,s+1] - Kstrike;<br>
                                    <br> # Payoff option value<br> Payoff {s in STATES[nPeriods]} : C[nPeriods,s] >= max(0, S[nPeriods,s] - Kstrike);<br>
                                    <br> # Objective<br> minimize OptionPrice : C[0,0];<br>
                                    <br> solve;
                                    <br>
                                    <br> printf "Option Price Value = %.2f\n", C[0,0];<br>
                                    <br> table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :<br> p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, C[p,s]~Option;<br>
                                    <br> end; <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleBPMAPO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="BPMAPO" class="modal-body modal-body-example">
                    /* # Binomial Pricing Model for an American Put Option <br>
                    <br> Determines the price of an American put option for an asset in which the<br> price model is a binomial tree. The option price is the minimum value<br> of a portfolio that replicates the option payoff at expiration, and can<br>                    payoff the early exercise of the option. (Data is from Hull, Sec 11.7).<br> */
                    <br>
                    <br> # Asset Model<br> param S0 := 50; # initial price <br> param r := 0.06; # mean return (annualized)<br> param sigma := 0.3; # volatility (annualized)<br>
                    <br> # Bond Price<br> param B0 := 1; # initial value<br> param rf := 0.05; # risk-free interest rate<br>
                    <br> # Option<br> param Kstrike := 52; # strike price<br> param Tf := 2; # time to expiration (years)<br>
                    <br> # Construct a recombining binomial tree<br> param nPeriods := 2;<br> set PERIODS := {0..nPeriods};<br> set STATES {p in PERIODS} := {0..p};<br> param u := exp(sigma*sqrt(Tf/nPeriods));<br> param d := 1/u;<br> param pr := (exp(r*Tf/nPeriods)-d)/(u-d);<br>
                    <br> param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;<br> param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));<br>
                    <br> # Replicating Portfolio<br> var P{p in PERIODS, s in STATES[p]};<br> var x{p in PERIODS, s in STATES[p]};<br> var y{p in PERIODS, s in STATES[p]};<br>
                    <br> portfolio {p in PERIODS, s in STATES[p]}: P[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];<br>
                    <br> # Self financing constraints<br> do {p in PERIODS, s in STATES[p] : p
                    < nPeriods}: <br>
                        x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= P[p+1,s];<br> up {p in PERIODS, s in STATES[p] : p
                        < nPeriods}: <br>
                            x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= P[p+1,s+1];<br>
                            <br> # Finance early exercise option<br> edo{p in PERIODS, s in STATES[p] : p
                            < nPeriods}: <br>
                                x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= Kstrike - S[p+1,s];<br> eup{p in PERIODS, s in STATES[p] : p
                                < nPeriods}: <br>
                                    x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= Kstrike - S[p+1,s+1];<br>
                                    <br> # Payoff option value<br> Payoff {s in STATES[nPeriods]} : P[nPeriods,s] >= max(0, Kstrike - S[nPeriods,s]);<br>
                                    <br> # Objective<br> minimize OptionPrice : P[0,0];<br>
                                    <br> solve;
                                    <br>
                                    <br> printf "Option Price Value = %.2f\n", P[0,0];<br>
                                    <br> table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :<br> p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, P[p,s]~Option;<br>
                                    <br> end; <br>
                                    <br>
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleBPMECO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="BPMECO" class="modal-body modal-body-example">
                    /* # Binomial Pricing Model for a European Call Option <br>
                    <br> Determines the price of a European call option for an asset in which the<br> price model is a binomial tree. The option price is the minimum value<br> of a portfolio that replicates the option payoff at expiration.<br> */
                    <br>
                    <br> # Asset Model<br> param S0 := 100; # initial price <br> param r := 0.06; # mean return (annualized)<br> param sigma := 0.3; # volatility (annualized)<br>
                    <br> # Bond Price<br> param B0 := 1; # initial value<br> param rf := 0.03; # risk-free interest rate<br>
                    <br> # Option<br> param Kstrike := 110; # strike price<br> param Tf := 1; # time to expiration (years)<br>
                    <br> # Construct a recombining binomial tree<br> param nPeriods := 10;<br> set PERIODS := {0..nPeriods};<br> set STATES {p in PERIODS} := {0..p};<br> param u := exp(sigma*sqrt(Tf/nPeriods));<br> param d := 1/u;<br> param pr := (exp(r*Tf/nPeriods)-d)/(u-d);<br>
                    <br> param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;<br> param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));<br>
                    <br> # Replicating Portfolio<br> var C{p in PERIODS, s in STATES[p]};<br> var x{p in PERIODS, s in STATES[p]};<br> var y{p in PERIODS, s in STATES[p]};<br>
                    <br> portfolio {p in PERIODS, s in STATES[p]}: C[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];<br>
                    <br> # Self financing constraints<br> do {p in PERIODS, s in STATES[p] : p
                    < nPeriods}: <br>
                        x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= C[p+1,s];<br> up {p in PERIODS, s in STATES[p] : p
                        < nPeriods}: <br>
                            x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= C[p+1,s+1];<br>
                            <br> # Payoff option value<br> Payoff {s in STATES[nPeriods]} : C[nPeriods,s] >= max(0, S[nPeriods,s] - Kstrike);<br>
                            <br> # Objective<br> minimize OptionPrice : C[0,0];<br>
                            <br> solve;
                            <br>
                            <br> printf "Option Price Value = %.2f\n", C[0,0];<br>
                            <br> table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :<br> p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, C[p,s]~Option;<br>
                            <br> end;
                            <br>

                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExampleBPMEPO" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="BPMEPO" class="modal-body modal-body-example">
                    /* # Binomial Pricing Model for a European Put Option <br>
                    <br> Determines the price of an European put option for an asset in which the<br> price model is a binomial tree. The option price is the minimum value<br> of a portfolio that replicates the option payoff at expiration, and can<br>                    payoff the early exercise of the option. (Data is from Hull, Sec 11.7).<br>
                    <br> */
                    <br>
                    <br> # Asset Model<br> param S0 := 50; # initial price <br> param r := 0.06; # mean return (annualized)<br> param sigma := 0.3; # volatility (annualized)<br>
                    <br> # Bond Price<br> param B0 := 1; # initial value<br> param rf := 0.05; # risk-free interest rate<br>
                    <br> # Option<br> param Kstrike := 52; # strike price<br> param Tf := 2; # time to expiration (years)<br>
                    <br> # Construct a recombining binomial tree<br> param nPeriods := 2;<br> set PERIODS := {0..nPeriods};<br> set STATES {p in PERIODS} := {0..p};<br> param u := exp(sigma*sqrt(Tf/nPeriods));<br> param d := 1/u;<br> param pr := (exp(r*Tf/nPeriods)-d)/(u-d);<br>
                    <br> param B {p in PERIODS, s in STATES[p]} := B0*(1 + rf*Tf/nPeriods)**p;<br> param S {p in PERIODS, s in STATES[p]} := S0*(d**(p-s))*(u**(s));<br>
                    <br> # Replicating Portfolio<br> var P{p in PERIODS, s in STATES[p]};<br> var x{p in PERIODS, s in STATES[p]};<br> var y{p in PERIODS, s in STATES[p]};<br>
                    <br> portfolio {p in PERIODS, s in STATES[p]}: P[p,s] = x[p,s]*B[p,s] + y[p,s]*S[p,s];<br>
                    <br> # Self financing constraints<br> do {p in PERIODS, s in STATES[p] : p
                    < nPeriods}: <br>
                        x[p,s]*B[p+1,s] + y[p,s]*S[p+1,s] >= P[p+1,s];<br> up {p in PERIODS, s in STATES[p] : p
                        < nPeriods}: <br>
                            x[p,s]*B[p+1,s+1] + y[p,s]*S[p+1,s+1] >= P[p+1,s+1];<br>
                            <br> # Payoff option value<br> Payoff {s in STATES[nPeriods]} : P[nPeriods,s] >= max(0, Kstrike - S[nPeriods,s]);<br>
                            <br> # Objective<br> minimize OptionPrice : P[0,0];<br>
                            <br> solve;
                            <br>
                            <br> printf "Option Price Value = %.2f\n", P[0,0];<br>
                            <br> table results {p in PERIODS, s in STATES[p]} OUT "JSON" "Binomial Tree" "Table" :<br> p~Period, s~State, B[p,s]~Bond, S[p,s]~Asset, P[p,s]~Option;<br>
                            <br> end;
                            <br>



                </div>
            </div>
        </div>
    </div>


    <!-- modal Example -->
    <div id="ModalExamplePolitical" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="PoliticalArb" class="modal-body modal-body-example">
                    /* # Arbitrage in Political Prediction Markets An arbitrage is an opportunity for an investor to allocate money among set of investments such that there is non-negative return for all outcomes. This situation is demonstrated below using data collected
                    on September 27, 2008 at 10:30am EST for in 2008 US Presidential Election prediction markets. The outcomes, which are assumed to exhaust all possibilities, are: 1 The Democratic Party Candidate wins the U.S. Election 2 The Republican
                    Party Candidate wins the U.S. Election Prices and payouts are gathered for these outcomes from three markets: 1 Intrade (Buy price for a $10 pay out) 2 IEM (Ask price for $1 pay out) 3 Betfair (Odds less 5% commission on winnings for
                    a $1 bet) Prices and payoffs are net of any transaction or trading costs. */ # Data set CONTRACTS dimen 2; param price{CONTRACTS}; param payout{CONTRACTS}; # Exact markets and events from set of contracts set MARKETS := setof {(m,e)
                    in CONTRACTS} m; set EVENTS := setof {(m,e) in CONTRACTS} e; # The decision variables are the amount invested in each contract. # The non-negativity condition means no shorting is allowed. var x{CONTRACTS} >= 0; # The total investment
                    is limited to $1,000 s.t. investment : sum{(m,e) in CONTRACTS} price[m,e]*x[m,e]
                    <=1 000; # The objective is maximize the worst-case payout var minpayout>= 0; s.t. arbitrage {e in EVENTS} : sum {m in MARKETS} payout[m,e]*x[m,e] >= minpayout; maximize obj: minpayout; solve; printf "Market Contract Price Payout Units Cost Payout\n" >> 'Summary for a $1,000 Investment'; printf "------
                        -------- ----- ------ ----- ---- ------\n" >> 'Summary for a $1,000 Investment'; printf {(m,e) in CONTRACTS} "%-10s %-16s %6.2f %6.2f %6.2f %6.2f %8.2f\n", m, e, price[m,e], payout[m,e], x[m,e], price[m,e]*x[m,e], payout[m,e]*x[m,e]
                        >> 'Summary for a $1,000 Investment'; table tout {(m,e) in CONTRACTS : x[m,e] > 0} OUT "GCHART" "Arbitrage" "PieChart" : (m&"-"&e)~Contract, x[m,e]; data; param : CONTRACTS : price payout := Intrade 'Democrat Wins' 5.59 10.00 Intrade
                        'Republican Wins' 4.30 10.00 IEM 'Democrat Wins' 0.64 1.00 IEM 'Republican Wins' 0.36 1.00 Betfair 'Democrat Wins' 1.00 1.48 Betfair 'Republican Wins' 1.00 2.95 ; end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleRiskNeutral" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="RiskNeutral" class="modal-body modal-body-example">
                    /* # Risk Neutral Analysis for _American Idol_ _American Idol_ was a singing competition televised in the United States from 2002 to 2016 in which the television audience voted for their favorite contestant in the final rounds. Each week the contestant
                    with the lowest number of votes was dropped until a winner emerged in the final episode. The intense interest in the singing competition attracted the attention of third-party agents who offered an opportunity to bet on the eventual
                    winner. Here we analyze a sample of the betting market from Season 12 of the show prior to the episode featureing the final nine singers. ## Model for Maximum Risk Free Return A betting agent will quote the payout for a wager on a
                    particular contestant. Label the agent \\(a\\), the contestant \\(c\\), and the amount wagered as \\(P_{c,a}(0)\\) (typically $100). Let \\(n_{c,a}\\) denote the number of bets an investor places on contestant \\(c\\) with agent \\(a\\).
                    We assume the agents will only accept non-negative wagers (i.e., no 'shorting') so that \\(n_{c,x} \geq 0\\). The total cost to the investor is \\[w(0)=\sum_{c\in C}\sum_{a\in A}P_{c,a}(0)n_{c,a}\\] If contestant \\(c\\) eventually
                    wins, the payout quoted by agent \\(a\\) is \\(P_{c,a}(1)\\), otherwise the payout is zero. If contestant \\(c\\) wins then the payoff from all agents is \\[\sum_{a \in A} P_{c,a}(1) n_{c,a}\\] A risk neutral investor seeks a betting
                    strategy offering a risk-free regardless of which contestant wins. For every contestant \\[\sum_{a\in A} P_{c,a}(1)n_{c,a} > (1+r_f)w(0) \qquad \forall c\in C \\] where \\(r_f\\) is the risk-free return. After substitution \\[\sum_{a\in
                    A} P_{c,a}(1)n_{c,a} > (1+r_f)\sum_{c\in C}\sum_{a\in A}P_{c,a}(0)n_{c,a} \qquad \forall c\in C \\] The notation is simplified by introducing a variable \\(x_{c,a} = P_{c,a}(0)n_{c,a}\\) equal to the value of the wager placed on contestant
                    \\(c\\) with agent \\(a\\). Then defining the total relative return for a wager on contestant \\(c\\). \\[p_{c,a} = \frac{P_{c,a}(1)}{P_{c,a}(0)}\\] leaves an inequality for each contestant that reads \\[\sum_{a \in A} p_{c,a} x_{c,a}
                    - (1 + r_f)\sum_{c\in C}\sum_{a\in A} x_{c,a} > 0 \qquad \forall c\in C\\] At this stage we have a set of linear inequalities in the non-negative variables \\ (x_{c,a}\\). Given data on payoffs, the total amount of money to wager,
                    and a risk-free rate \\(r_f\\), we can try to compute a solution that provides a return higher than the risk-free rate. If such a solution exists then there exists an arbitrage opportunity. ## Farka's Lemma Arbitrages, however, are
                    rare. When they arise it is likely investors will exploit the situation thereby driving the market back to a new price/demand equilibrium. So rather than seek solutions to a problem where a solution isn't likely to exist, we change
                    the formulation using a version of Farka's lemma. Consider two sets of linear inequalities, the first written \\[A \gg 0\\] \\[x \geq 0 \\] where the matrix/vector notation \\(A \gg 0\\) means a strict inequality between corresponding
                    elements of vector quantities, and the second written as \\[ A^Ty \leq 0 \\] \\[ y \geq 0\\] Farka's lemma states that one or the other of these two sets has a feasible solution, but not both. Applying this result, an arbitrage does
                    not exist if there are variables \\(y_c \geq 0\\) such that \\[p_{c,a}y_c - (1 + r_f)\sum_{c \in C}y_c \leq 0 \qquad \forall a \in A, \forall c \in C\\] ## Solution for Maximum Risk-Free Return It's easy to see that if \\(r_f\\) is
                    large enough, then an aribitrage can't exist. The smallest value for which an arbitrage does not exist (therefore an upper bound on the attainable risk-free return obtained by any betting strategy) is given by \\[\min_{y_c \geq 0}
                    r_f\\] subject to \\[p_{c,a}y_c \leq (1 + r_f) \qquad \forall a \in A, \forall c \in C\\] \\[\sum_{c \in C}y_c = 1\\] The parameters \\(y_c\\) can be interpreted as a risk-neutral probability for contestant \\(c\\) to win the competition.
                    The actual order of finish is listed below for contestants in Season 12 of _American Idol_, so you can see how well this works. */ set AGENTS; set CONTESTANTS; param payout{CONTESTANTS,AGENTS}; param finish{CONTESTANTS}; var x{CONTESTANTS,AGENTS}
                    >= 0; var y{CONTESTANTS} >= 0; var rf; s.t. total: sum{c in CONTESTANTS, a in AGENTS} x[c,a] = 1; s.t. return {c in CONTESTANTS} : sum{a in AGENTS} payout[c,a]*x[c,a] >= 100*(1 + rf); s.t. prob : sum{c in CONTESTANTS} y[c] = 1; s.t.
                    noarb {c in CONTESTANTS, a in AGENTS} : (1+rf)*100 >= payout[c,a]*y[c]; minimize obj: rf; solve; printf "Maximum risk-free return = %7.4f\n\n", rf; printf "%15s %6s", "CONTESTANT", "y[c]"; printf {a in AGENTS} : "%14s", a; printf "\n";
                    for {c in CONTESTANTS} { printf "%15s(%1d) %6.3f",c, finish[c], y[c]; printf {a in AGENTS} : " %6.2f", 100*x[c,a]; printf "\n"; } printf "%15s %6s", "TOTALS", " "; for {a in AGENTS} : printf " %6.2f", sum{c in CONTESTANTS} 100*x[c,a];
                    data; set AGENTS := Diamond SportsBetting Bovada ; param : CONTESTANTS : finish := 'Candice Glover' 1 'Angela Miller' 3 'Kree Harrison' 2 'Amber Holcomb' 4 'Janelle Arthur' 5 'Lazaro Arbos' 6 'Burnell Taylor' 7 'Devin Velez' 8 'Paul
                    Jolley' 9 ; param payout : Diamond SportsBetting Bovada := 'Candice Glover' 115 190 200 'Angela Miller' 125 180 225 'Kree Harrison' 230 180 275 'Janelle Arthur' 1100 1150 1200 'Lazaro Arbos' 1100 950 1400 'Amber Holcomb' 1100 800 1200
                    'Paul Jolley' 2800 4000 3300 'Burnell Taylor' 2100 2500 2500 'Devin Velez' 2600 3500 3300 ; end;
                </div>
            </div>
        </div>
    </div>

    <!-- modal Example -->
    <div id="ModalExampleSavingRetirement" class="modal" role="dialog">
        <div class="modal-dialog">
            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                <div id="retirement" class="modal-body modal-body-example">
                    /* # Saving for Retirement Retirement savings is an often neglected priority in personal finance. This model demonstrates the computation of a simple savings plan over a professional career that accommodates several major expenditures in addition to meeting
                    a savings target equal to eight times salary at retirement. The model assumes a constant rate of inflation <span class="math">\(r_f\)</span>, a constant rate of return on investments <span class="math">\(r_i\)</span>,
                    and a salary model
                    <span class="math">\[S_k = \frac{(1+r_f)^k (\alpha + \beta k)}{1 + \beta k}S_{\infty}\]</span> where <span class="math">\(k\)</span> denotes year, <span class="math">\(S_{\infty}\)</span> the ultimate salary, <span class="math">\(\alpha\)</span>                    is the starting salary as a fraction of the ultimate salary, and <span class="math">\(\beta\)</span> is a constant with units of inverse time reflecting the relative speed of career growth. Examples of additional expenses is a provision
                    to cover the college tuition expenses of several children. The optimization objective is to determine a bound on the fraction of salary that needs to be saved to meet the projected expenses. An interesting exercise is to modify the
                    model to include other expenses typical of a professional career, such as the purchase of real estate, and the management of personal debt. But be careful not to read too much into the results of this type of modeling. This model is
                    deterministic while real life is not! */ /* Investment Parameters */ param T := 40; # time Horizon (years) param Nper := 1*T; # total number of periods param Ri := 0.05; # annual investment return param Rf := 0.03; # annual inflation
                    (discount) param Wi := 0; # initial wealth /* calculated quantities */ set N := 0..Nper; # index set param dT := T/Nper; # time step param t{n in N} := n*dT; # time param ri := Ri*dT; # investment return/period param rf := Rf*dT; #
                    inflation/period /* salary model */ param salary{n in N} := (150000*(1+rf)**n)*(0.4+0.1*t[n])/(1+0.1*t[n]); /* saving decision variables */ var w{N} >= 0; # wealth at the start of period n var u{N} >= 0; # savings in period n var fSave;
                    # fraction of salary saved /* what things are we saving for? */ set EXPENSES := {"TuitionA","TuitionB","TuitionC"}; var x{N,EXPENSES} >=0; /* retirement goal: savings equal to 8 times salary */ s.t. Retirement: w[Nper] = 8*salary[Nper];
                    /* tuition: present value of 40000/year for each child */ s.t. TuitionA {n in 18/dT..21/dT}: x[n,"TuitionA"] = 40000*(1+rf)**n; s.t. TuitionB {n in 20/dT..23/dT}: x[n,"TuitionB"] = 40000*(1+rf)**n; s.t. TuitionC {n in 22/dT..25/dT}:
                    x[n,"TuitionC"] = 40000*(1+rf)**n; /* wealth accumulation */ s.t. IC: w[0] = Wi; s.t. FC {n in 1..Nper}: w[n] = (1+ri)*(w[n-1] + u[n-1]) - sum{e in EXPENSES}x[n,e]; /* Objective: Minimize fraction of the salary that is saved */ s.t.
                    MaxSavings {n in 0..Nper}: u[n]
                    <=f Save*salary[n]; /* minimize present value of the savings plan */ minimize SaveFraction: fSave; solve; table tab0 {n in 0..Nper} OUT "JSON" "Projected Wealth" "LineChart": n~Year, w[n]~Wealth; table tab1 {n in 0..Nper} OUT "JSON"
                        "Salary, Savings, and Expenses" "LineChart": n~Year, salary[n]~Salary, u[n]~Savings, sum{e in EXPENSES}x[n,e]~MajoExpenses; /* print table of results */ printf "Savings as fraction of Salary: %6.4f \n\n", fSave; printf
                        "  n   Year  Savings   Salary   fSave   Wealth "; printf {e in EXPENSES}: " %10s", e; printf "\n\n"; for {n in 0..Nper} { printf "%3d  %5.2f  %7.0f %8.0f  %6.4f %8.0f %8.0f", n, n*dT, u[n], salary[n], u[n]/salary[n], w[n]; printf {e in EXPENSES}: " %10.0f", x[n,e]; printf "\n";
                        } end; </div>
                </div>
            </div>
        </div>



        <!-- modal Example -->
        <div id="ModalExampleNormal" class="modal" role="dialog">
            <div class="modal-dialog">
                <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                    <div id="normal" class="modal-body modal-body-example">
                        /* # Generating Random Numbers for a Multivariate Normal Distribution Applications of optimization in finance and other fields often require sampling of a multivariate normal distribution. We demonstrate a simple technique for generating samples in GMPL.
                        The data section defines an index set \\(I\\), population mean \\(\mu\{I\}\\), and population covariance \\(\Sigma\{I,I\}\\). Optionally the data section can specify the number of samples to use in verifying the distribution. */
                        /* Jeff Kantor December 4, 2009 Revised: December 7, 2009 to add a 'seeding' of the PRNG */ /* Index Set */ set I; /* Return and Covariance parameters */ param Mu {I}; param Sigma {I,I}; /* Simulation Parameters */ param N >= 1,
                        default 50; set T := 1..N; /* Cholesky lower triangular decomposition */ param Chol{i in I, j in I : i >= j} := if i = j then sqrt(Sigma[i,i]-(sum {k in I : k
                        < i} (Chol[i,k]*Chol[i,k]))) else (Sigma[i,j]-sum{k in I : k < j} Chol[i,k]*Chol[j,k])/Chol[j,j]; /* Because there is no way to seed the PRNG, a workaround */ param utc :=p rod {1..2} (gmtime()-1000000000); param seed :=u tc - 100000*floor(utc/100000);
                            check sum{1..seed} Uniform01()>
                            0; /* Compute Multivariate Normal Samples */ param z{i in I, t in T} := Normal(0,1); param x{i in I, t in T} := Mu[i] + sum {j in I : i >= j} Chol[i,j]*z[j,t]; /* Compare sample with population statistics */ param xbar{i in I} := (1/card(T))*sum {t in
                            T} x[i,t]; param Cov{i in I, j in I} := (1/card(T))*sum {t in T} (x[i,t]-xbar[i])*(x[j,t]-xbar[j]); /* Show results */ printf "POPULATION PARAMETERS\n\n"; printf "Mu\n"; printf {i in I} "%5s %7.4f\n", i, Mu[i]; printf "\nSigma\n";
                            printf " "; printf {j in I} " %7s ", j; printf "\n"; for {i in I} { printf "%5s " ,i; printf {j in I} " %7.4f ", Sigma[i,j]; printf "\n"; } printf "\n\nSAMPLE STATISTICS (N = %d)\n\n",N; printf "Mean\n"; printf {i in I} "%5s
                            %7.4f\n", i, xbar[i]; printf "\nCovariance\n"; printf " "; printf {j in I} " %7s ", j; printf "\n"; for {i in I} { printf "%5s " ,i; printf {j in I} " %7.4f ", Cov[i,j]; printf "\n"; } data; /* Data from 3 years of monthly
                            returns for four selected stocks. */ /* Index set I, and parameter Mu of population means */ param : I : Mu := AAPL 0.0308 GE -0.0120 GS 0.0027 XOM 0.0018 ; /* Positive Definite Sigma */ param Sigma : AAPL GE GS XOM := AAPL
                            0.0158 0.0062 0.0088 0.0022 GE 0.0062 0.0136 0.0064 0.0011 GS 0.0088 0.0064 0.0135 0.0008 XOM 0.0022 0.0011 0.0008 0.0022 ; end;


                    </div>
                </div>
            </div>
        </div>

        <!-- modal Example -->
        <div id="ModalExamplePiecewise" class="modal" role="dialog">
            <div class="modal-dialog">
                <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                    <div id="piecewise" class="modal-body modal-body-example">
                        /* # Piecewise Linear Interpolation A common requirement is to incorporate a nonlinear constraint or objective function into an MIP problem. Normally special ordered sets of type 2 (SOS2) are used to model these situations, but SOS2 is not implemented
                        in GLPK. Based on notes by Andrew Makhorin and Robbie Morrison, the following model demonstrates piecewise linear interpolation in MathProg. */ param N; # Interpolation Points param xi{0..N}; param fi{0..N}; var z{1..N} binary;
                        # z[n] denotes the nth interval var s{1..N} >= 0; var x; var f; s.t. A {n in 1..N} : s[n]
                        <=z [n]; s.t. B : 1=s um{n in 1..N} z[n]; s.t. C : x=s um{n in 1..N} (xi[n-1]*z[n] + (xi[n]-xi[n-1])*s[n]); s.t. D : f=s um{n in 1..N} (fi[n-1]*z[n] + (fi[n]-fi[n-1])*s[n]); maximize Objective : f; solve; table tab1 {n in 0..N} OUT "JSON"
                            "Piecewise Linear Function" "LineChart" : xi[n], fi[n], f~Optimum; data; param N :=1 0; param : xi fi :=0 0.0 0.0 1 0.1 0.12 2 0.2 0.22 3 0.3 0.45 4 0.4 0.33 5 0.5 0.50 6 0.6 0.62 7 0.7 0.81 8 0.8 0.75 9 0.9 0.72 10 1.0 0.50 ; end; </div>
                    </div>
                </div>
            </div>


            <!-- modal Example -->
            <div id="ModalExampleSorting" class="modal" role="dialog">
                <div class="modal-dialog">
                    <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                        <div id="Sorting" class="modal-body modal-body-example">
                            /* # Sorting in MathProg MathProg is a lean language with a limited number of functions and utilities. Demonstrated below are several techniques for sorting sets by value of parameters or decision variables. These techniques may be useful in other contexts.
                            These ideas are attributable to xypron and Andrew Makhorin on the help-glpk mail list. */ set I; param a{I}; /* Unordered Set */ printf "\nUnordered Set\n"; printf {i in I} " %8s %7.4f\n", i, a[i]; /* Set in Ascending Order.
                            r[i] computes the rank-order of corresponding elements in a[i]. The list is then scanned in the domain of a printf statement. This is an order n^3 technique which appears to be the best one can do in GMPL. */ printf "\nAscending
                            Order\n"; param r{i in I} := 1 + sum {j in I} if (a[j]
                            < a[i] || a[j]==a [i] && j < i) then 1; printf {k in 1..card(I), i in I: k==r [i]} "%3d: %8s  %7.4f\n", r[i], i, a[i]; /* Set in Descending Order with comparison within the domain spec */ printf "\nDescending Order\n"; param s{i in I} :=1 + sum {j in
                                I : a[i] < a[j] || a[i]==a [j] && i < j} 1; printf {k in 1..card(I), i in I: k==s [i]} "%3d: %8s  %7.4f\n", s[i], i, a[i]; /* There may be instances where it would be useful to compute rank-order in the optimization model,
                                such as portfolio optimization with a VaR constraint, for example. */ param BigM :=1 + sum{i in I} abs(a[i]); var y{i in I, j in I : i<>j } binary; # y[i,j] = 0 if a[i]
                                <=a [j] var t{i in I}; # rank-order of a[i] /* Pair of disjunctive constraints to force ordering of a[i] */ s.t. A{i in I, j in I : i<>j}: a[i]
                                    <=a [j] + BigM*y[i,j]; s.t. B{i in I, j in I : i<>j}: a[j]
                                        <=a [i] + BigM*(1-y[i,j]); /* Forces a tie breaker if a[i]=a [j] */ s.t. C{i in I, j in I : i<>j}: y[i,j] + y[j,i] = 1; /* t[i] is rank-order could be computed post-solution */ s.t. D{i in I}: t[i] = 1 + sum{j in I: i
                                            <>j} y[i,j]; solve; printf "\nAscending Order by Optimization\n"; printf {k in 1..card(I), i in I: k ==t[i]} "%3d: %8s %7.4f\n", t[i], i, a[i]; data; param: I: a := alpha 1 beta 2 gamma 2 delta -1.2 chewy -1.3
                                                fruity 3 gummy 10 doug -3 ; end;
                        </div>
                    </div>
                </div>
            </div>

            <!-- modal Example -->
            <div id="ModalExampleDataReconciliation" class="modal" role="dialog">
                <div class="modal-dialog">
                    <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                        <div id="DataReconciliation" class="modal-body modal-body-example">
                            /* # Data Reconciliation and Gross Error Detection The following demonstration was motivated by a former student Matt N. who was exploring methods for assessing measurement information in a refinery application. The illustration was adapted from Chapter
                            1 of "Reconciliation & Gross Error Detection: An Intelligent Use of Process Data" by Shankar Narasimhan and Cornelius Jordache (Gulf Publishing, 2000). 1/1 2/2 4/3 6/5 -------- SPLIT ----- HTEXG ----- MIXER -------- | ^ | |
                            | 3 5/4 | +-------> VALVE --------+ The flow sheet is labeled by \\(s/k\\) pairs which refer to stream \\(s\\) and measurement \\(k\\). Streams are numbered \\(s\\) in \\(1..S\\) and sensors are numbered \\(k\\) in \\(1..K\\).
                            The parameter \\(s[k]\\) denotes the stream associated with measurement \\(k\\). Given sensor measurements \\(y_k\\), the task is to infer values for the flowrates \\(x_{s_k}\\) using mass balance equations and a sensor model
                            \\[ \|y_k-x_{s_k}| \leq e_k + M g_k \\] \\[ |e_k| \leq e^{max}_k \\] \\(g_k\\) is a binary variable indicating the presence of a gross error in sensor \\(k\\). \\(M\\) is a big number. A gross error occurs if the measured data
                            is not consistent with sensor model and mass balances. The optimization objective is to find an estimate of mass flows minimizing the number of gross sensor errors. */ /* Sets */ set STREAMS; set SENSORS; set UNITS; /* Mass
                            Balances Coefficients */ param A{UNITS,STREAMS} default 0; /* Sensors Parameters */ param y{SENSORS} >= 0; # Measurement Data param s{SENSORS} > 0; # Stream measured by each sensor param emax{SENSORS} >= 0; # Bound on error
                            for each sensor param bigM := 100; # Big M /* Stream Variables */ var x{STREAMS} >= 0; /* Sensor Variables */ var epos{SENSORS} >= 0; var eneg{SENSORS} >= 0; var gerr{SENSORS} binary; # Gross Errors /* Optimization Criterion
                            */ minimize L1: sum {k in SENSORS} (epos[k]+eneg[k] + bigM*gerr[k]); /* Mass Balances */ s.t. MASSBAL {i in UNITS}: sum{j in STREAMS} A[i,j]*x[j] = 0; /* Error Model */ s.t. s_err {k in SENSORS}: y[k] = x[s[k]] + epos[k] -
                            eneg[k]; s.t. e_pos {k in SENSORS}: epos[k]
                            <=e max[k] + bigM*gerr[k]; s.t. e_neg {k in SENSORS}: eneg[k] <=e max[k] + bigM*gerr[k]; /* Solve and Display Solution */ solve; printf "Measurement Reconciliation"; printf "\n\n   Sensor    Measured     Reconciled    Difference    GrossError"; for {k
                                in SENSORS}{ printf "\n      %s      %7.2f       %7.2f      %7.2f", k,y[k],x[s[k]],(epos[k]-eneg[k]),gerr[k]; printf "         %3s", if gerr[k]=1 then "X" else " "; } printf "\n\n\nStream Estimates"; printf
                                "\n\n   Stream    Estimate"; printf {i in STREAMS} "\n      %s      %7.2f",i,x[i]; table tab1 {k in SENSORS} OUT "JSON" "Measurement Reconciliation" "ColumnChart": k~Sensor, y[k]~Measurement, x[s[k]]~Reconciled; table tab2 {k in SENSORS} OUT "JSON"
                                "Measurement Error" "ColumnChart": k~Sensor, (epos[k]-eneg[k])~Error; data; /* All of the relevant sensor information is given in the data section. The relevant information includes the number of sensors, and a table indexed by sensor number
                                k with information on which stream is measured (s[k]), the measurement (y[k]), and 'no-penalty' range for measurement errors (emax[k]). */ set UNITS :=S PLIT HTEXG VALVE MIXER; set STREAMS :=1 2 3 4 5 6; /* Mass Balance Coefficients
                                */ param A : 1 2 3 4 5 6 :=S PLIT -1 1 1 . . . HTEXG . -1 . 1 . . VALVE . . -1 . 1 . MIXER . . . 1 1 -1 ; /* Sensors and Measurement Data*/ param: SENSORS: s y emax :=1 1 101.91 1.75 2 2 68.45 1.75 3 4 64.20 1.75 4 5 36.44
                                1.75 5 6 98.88 1.75 ; end; </div>
                        </div>
                    </div>
                </div>


                <!-- modal Example -->
                <div id="ModalExampleSolvay" class="modal" role="dialog">
                    <div class="modal-dialog">
                        <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                            <div id="solvay" class="modal-body modal-body-example">
                                /* # Generation-Consumption Analysis of the Solvay Process The Solvay process was invented in the mid-nineteenth century for the production of soda ash (Sodium Carbonate) from sea salt (Sodium Chloride) and limestone (Calcium Carbonate). Soda ash is an
                                essential raw material for the production of soap, glass, textiles, and numerous inorganic products. Prior to that time these needs were met by the production of potash from trees, which led to the deforestation of Europe,
                                and later the production of soda ash from the noxious LeBlance process. In a brilliant piece of early process engineering, Ernest Solvay utilized an ammonia based chemistry in which the necessary chemicals are regenerated
                                within the process. The following model performs a generation/consumption analysis of the four chemical reactions comprising the Solvay process. The objective function is to maximize the atom efficiency, which is the fraction
                                of the total mass of raw materials that ends up in the desired product, in this case soda ash. */ set ATOMS; set SPECIES; set REACTIONS; param amu{ATOMS} >= 0; param name{SPECIES} symbolic; param formula{SPECIES,ATOMS}
                                >= 0; param stoich{SPECIES,REACTIONS}; # Compute Molecular Weights param mw{s in SPECIES} := sum{a in ATOMS} amu[a]*formula[s,a]; # Check for balanced reactions check {a in ATOMS, r in REACTIONS}: sum{s in SPECIES} stoich[s,r]*formula[s,a]
                                = 0; # Generation/Consumption Analysis set RAW_MATERIALS within SPECIES; set PRODUCTS within SPECIES; set BYPRODUCTS := (SPECIES diff RAW_MATERIALS diff PRODUCTS); var x{REACTIONS}; var n{SPECIES}; s.t. A {s in SPECIES}
                                : n[s] = sum{r in REACTIONS} stoich[s,r]*x[r]; s.t. B {s in RAW_MATERIALS}: sum{r in REACTIONS} n[s]
                                <=0 ; s.t. C {s in SPECIES diff RAW_MATERIALS}: sum{r in REACTIONS} n[s]>= 0; s.t. D : sum{s in RAW_MATERIALS} -n[s]
                                    <=1 ; maximize atom_efficiency: sum{s in PRODUCTS} mw[s]*n[s]; solve; printf "Atom Efficiency = %6.4f\n\n", (sum{s in PRODUCTS} mw[s]*n[s])/(sum{s in RAW_MATERIALS} -mw[s]*n[s]); printf "Process Stoichiometry\n"; printf "%10s", ' '; printf {r in REACTIONS}
                                        "%7s", r; printf "%7s\n", "NET"; printf "%-10s", 'Rxn Wt.'; printf {r in REACTIONS} "%7.2g", x[r]; printf "\n"; for {s in SPECIES} { printf "%-10s", s; printf {r in REACTIONS} "%7g", stoich[s,r]; printf "%7.2g", n[s]; printf
                                        "\n"; } table chrt2 {s in RAW_MATERIALS} OUT "GCHART" "Raw Materials Consumed" "PieChart" : s, -mw[s]*n[s]~Consumed; table chrt3 {s in SPECIES diff RAW_MATERIALS} OUT "GCHART" "Products and By-Products Generated "
                                        "PieChart" : s, mw[s]*n[s]~Generated; table tab1 {s in RAW_MATERIALS} OUT "GCHART" "Raw Materials" "Table" : name[s]~Raw_Material, s~Formula, mw[s]~MolWt, sum{r in REACTIONS} max(0,(mw[s]*stoich[s,r]*x[r]))~Generated, sum{r
                                        in REACTIONS} max(0,-(mw[s]*stoich[s,r]*x[r]))~Consumed, mw[s]*n[s]~Net; table tab1 {s in PRODUCTS} OUT "GCHART" "Products" "Table" : name[s]~Product, s~Formula, mw[s]~MolWt, sum{r in REACTIONS} max(0,(mw[s]*stoich[s,r]*x[r]))~Generated,
                                        sum{r in REACTIONS} max(0,-(mw[s]*stoich[s,r]*x[r]))~Consumed, mw[s]*n[s]~Net; table tab3 {s in BYPRODUCTS} OUT "GCHART" "Byproducts" "Table" : name[s]~Byproduct, s~Formula, mw[s]~MolWt, sum{r in REACTIONS} max(0,(mw[s]*stoich[s,r]*x[r]))~Generated,
                                        sum{r in REACTIONS} max(0,-(mw[s]*stoich[s,r]*x[r]))~Consumed, mw[s]*n[s]~Net; data; param : ATOMS : amu :=C 12.011 Ca 40.08 Cl 35.45 H 1.0079 N 14.0067 Na 22.99 O 15.99994 S 32.06 ; param : SPECIES : name :=N H3 Ammonia
                                        NH4Cl Ammonium_Chloride CaCO3 Calcium_Carbonate CaCl2 Calcium_Chloride NaCl Sodium_Chloride CaO Calcium_Oxide CO2 Carbon_Dioxide Na2CO3 Sodium_Carbonate NaHCO3 Sodium_Bicarbonate H2O Water ; set RAW_MATERIALS :=N aCl
                                        CaCO3; set PRODUCTS :=N a2CO3; param formula default 0: C Ca Cl H N Na O :=N H3 . . . 3 1 . . NH4Cl . . 1 4 1 . . CaCO3 1 1 . . . . 3 CaCl2 . 1 2 . . . . NaCl . . 1 . . 1 . CaO . 1 . . . . 1 CO2 1 . . . . . 2 Na2CO3
                                        1 . . . . 2 3 NaHCO3 1 . . 1 . 1 3 H2O . . . 2 . . 1 ; set REACTIONS :=R 1 R2 R3 R4; param stoich default 0: R1 R2 R3 R4 :=N H3 -1 . 2 . NH4Cl 1 . -2 . CaCO3 . -1 . . CaCl2 . . 1 . NaCl -1 . . . CaO . 1 -1 . CO2 -1
                                        1 . 1 Na2CO3 . . . 1 NaHCO3 1 . . -2 H2O -1 . 1 1 ; end; </div>
                            </div>
                        </div>
                    </div>


                    <!-- modal Example -->
                    <div id="ModalExampleMAD" class="modal" role="dialog">
                        <div class="modal-dialog">
                            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                                <div id="MAD" class="modal-body modal-body-example">
                                    /* # Portfolio Optimization using Mean Absolute Deviation Konno and Yamazaki (1990) proposed a linear programming model for portfolio optimization in which the risk measure is mean absolute deviation (MAD). This model computes a portfolio minimizing MAD
                                    subject to a lower bound on return. In contrast to the classical Markowitz portfolio, the MAD criterion requires a data set consisting of returns on the investment assets. The data set may be an historical record or
                                    samples from a multivariate statistical model of portfolio returns. The MAD criterion produces portfolios with properties not shared by the Markowitz portfolio, including second degree stochastic dominance. Below we
                                    demonstrate portfolio optimization with the MAD criterion where data is generated by sampling a multivariate normal distribution. Given mean return \\(r\\) and the Cholesky decomposition of the covariance matrix \(\Sigma\)
                                    (i.e., \\(C\\) such that \\(CC^T = \Sigma\\) ), we compute \\(r_t = r + C z_t\\) where the elements of \\(z_t\\) are zero mean normal variates with unit variance. The rest of the formulation is adapted from "Optimization
                                    Methods in Finance" by Gerald Curnuejols and Reha Tutuncu (2007) which, in turn, follows an implementation due to Fienstein and Thapa (1993). A complete tutorial on the implementation of this model is available on GLPK
                                    wikibook.
                                    <a rel="external" href="http://en.wikibooks.org/wiki/GLPK/Portfolio_Optimization">A 
    complete tutorial describing the implementation of this model</a> is available on <a rel="external" href="http://en.wikibooks.org/wiki/GLPK/">GLPK wikibook</a>. */ /* Stock Data */ set S; # Set of stocks param r{S};
                                    # Means of projected returns param cov{S,S}; # Covariance of projected returns param r_portfolio default (1/card(S))*sum{i in S} r[i]; # Lower bound on portfolio return /* Generate sample data */ /* Cholesky Lower Triangular
                                    Decomposition of the Covariance Matrix */ param c{i in S, j in S : i >= j} := if i = j then sqrt(cov[i,i]-(sum {k in S : k
                                    < i} (c[i,k]*c[i,k]))) else (cov[i,j]-sum{k in S : k < j} c[i,k]*c[j,k])/c[j,j]; /* Because there is no way to seed the PRNG, a workaround */ param utc :=p rod {1..2} (gmtime()-1000000000); param seed :=u tc - 100000*floor(utc/100000); check sum{1..seed}
                                        Uniform01()> 0; /* Normal random variates */ param N default 5000; set T := 1..N; param zn{j in S, t in T} := Normal(0,1); param rt{i in S, t in T} := r[i] + sum {j in S : j
                                        <=i } c[i,j]*zn[j,t]; /* MAD Optimization */ var w{S}>= 0; # Portfolio Weights with Bounds var y{T} >= 0; # Positive deviations (non-negative) var z{T} >= 0; # Negative deviations (non-negative) minimize MAD: (1/card(T))*sum {t in T} (y[t] + z[t]); s.t. C1: sum {s
                                            in S} w[s]*r[s] >= r_portfolio; s.t. C2: sum {s in S} w[s] = 1; s.t. C3 {t in T}: (y[t] - z[t]) = sum{s in S} (rt[s,t]-r[s])*w[s]; solve; /* Report */ /* Input Data */ printf "Stock Data\n\n"; printf " Return
                                            Variance\n"; printf {i in S} "%5s %7.4f %7.4f\n", i, r[i], cov[i,i]; printf "\nCovariance Matrix\n\n"; printf " "; printf {j in S} " %7s ", j; printf "\n"; for {i in S} { printf "%5s " ,i; printf {j in S} "
                                            %7.4f ", cov[i,j]; printf "\n"; } /* MAD Optimal Portfolio */ printf "\nMinimum Absolute Deviation (MAD) Portfolio\n\n"; printf " Return = %7.4f\n",r_portfolio; printf " Variance = %7.4f\n\n", sum {i in S, j
                                            in S} w[i]*w[j]*cov[i,j]; printf " Weight\n"; printf {s in S} "%5s %7.4f\n", s, w[s]; printf "\n"; table tab0 {s in S} OUT "JSON" "Optimal Portfolio" "PieChart": s, w[s]~PortfolioWeight; table tab1 {s in S}
                                            OUT "JSON" "Asset Return versus Volatility" "ScatterChart": sqrt(cov[s,s])~StDev, r[s]~Return; table tab2 {s in S} OUT "JSON" "Portfolio Weights" "ColumnChart": s~Stock, w[s]~PortfolioWeight; table tab3 {t in
                                            T} OUT "JSON" "Simulated Portfolio Return" "LineChart": t~month, (y[t] - z[t])~PortfolioReturn; /* Simulated Return data in Matlab Format */ /* printf "\nrt = [ ... \n"; for {t in T} { printf {s in S} "%9.4f",rt[s,t];
                                            printf "; ...\n"; } printf "];\n\n"; */ data; /* Data for monthly returns on four selected stocks for a three year period ending December 4, 2009 */ param N := 200; param r_portfolio := 0.01; param : S : r :=
                                            AAPL 0.0308 GE -0.0120 GS 0.0027 XOM 0.0018 ; param cov : AAPL GE GS XOM := AAPL 0.0158 0.0062 0.0088 0.0022 GE 0.0062 0.0136 0.0064 0.0011 GS 0.0088 0.0064 0.0135 0.0008 XOM 0.0022 0.0011 0.0008 0.0022 ; end;
                                </div>
                            </div>
                        </div>
                    </div>



                    <!-- modal Example -->
                    <div id="ModalExamplePlantExpansion" class="modal" role="dialog">
                        <div class="modal-dialog">
                            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                                <div id="PlantExpansion" class="modal-body modal-body-example">
                                    /* # Scenario Analysis for a Plant Expansion Description to be written. Problem Data from Johannes Bisschop, "AIMMS Optimization Modeling", Paragon Decision Sciences, 1999. */ set PLANTS; # Set of plant types set DEMAND; # Demand Segments set SCENARIOS;
                                    # Planning Scenarios param e{PLANTS}; # Current Plant Capacity param C{PLANTS}; # Capital Cost per unit Expansion param O{PLANTS}; # Operating Cost [k$/GWh] param T{DEMAND}; # Time Periods for Demand Segments param
                                    D{DEMAND,SCENARIOS}; # Demand Scenarios var x {PLANTS} >= 0; # Plant Expansion var y {PLANTS,DEMAND,SCENARIOS} >= 0; # Operating Schedule var v {SCENARIOS}; # Variable Cost var capcost; # Capital Cost minimize COST:
                                    capcost + sum {s in SCENARIOS} 0.25*v[s]; s.t. CAPCOST: capcost = sum{p in PLANTS} C[p]*(e[p]+x[p]); s.t. VARCOST {s in SCENARIOS}: v[s] = sum {p in PLANTS, d in DEMAND} T[d]*O[p]*y[p,d,s]; s.t. DEMANDS {p in PLANTS,
                                    s in SCENARIOS}: e[p] + x[p] >= sum {d in DEMAND} y[p,d,s]; s.t. C4 {d in DEMAND, s in SCENARIOS} : D[d,s] = sum {p in PLANTS} y[p,d,s]; solve; table results {p in PLANTS} OUT "JSON" "Optimal Expansion" "Table" : p~Plant,
                                    O[p]~Unit_Cost, e[p]~Current_Cap, x[p]~Exp_Cap, x[p]+e[p]~Total_Cap; data; set SCENARIOS := S1 S2 S3 S4; param: DEMAND: T := Base 24 Peak 6 ; param: PLANTS: e C O:= Coal 1.75 200 30 Hydro 2.00 500 10 Nuclear 0.00 300
                                    20 Grid 0.00 0 200 ; param D : S1 S2 S3 S4 := Base 8.25 10.0 7.50 9.00 Peak 2.50 2.00 2.50 1.50 ; end;
                                </div>
                            </div>
                        </div>
                    </div>


                    <!-- modal Example -->
                    <div id="ModalExampleGambling" class="modal" role="dialog">
                        <div class="modal-dialog">
                            <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                                <div id="RNGambling" class="modal-body modal-body-example">
                                    /* ## Stochastic Dynamic Programming: Risk Neutral Gambler ### Problem Statement The risk neutral gambler enters a game with the idea of betting until he or she is either reaches a goal \\(N\\) or runs out of money. Given a stake \\(x\\) and wager \\(u\\),
                                    the result is a stake that is either \\(x+u\\) with probability \\(p\\), or a stake \\(x-u\\) with probability \\(q\\). The probabilities sastisfy the inequality \\[p + q \leq 1\\] The wager must be smaller than the
                                    stake or any maximum wager established for the game. To encourage risk taking, the future value of money is discounted by a factor \\(a \leq 1\\). Given an initial stake \\(x
                                    < N\\), what is the optimal gambling strategy? ### Formulation This classic problem in Dynamic Programming is discussed, for example, by Sutton and Barto in "Reinforcement Learning" (MIT Press, 1998). The function \\(V(k,x)\\) is the expected value of
                                        the game after the kth wager and with a stake \\(x\\). If the gambler reaches the goal of winning a stake \\(N\\) at \\(k\\) then the value of the game is \\(V(k,N)=N \\). Or if the gamble loses everything, then \\(V(k,0)=0
                                        \\). Otherwise, for \\(x < N\\), the Bellman equation for optimality provides the recursion \\[V(k-1,x)=a \max_u [ p V(k,x+u) + q V(k,x-u) ]\\] where \\(a\\) is the discount factor for future values. The maximization
                                        is over the set of possible bets ranging from \\(0\\) to the minimum of \\(x\\), \\(N-x\\), or the bet limit \\(B\\). Note that the state space and set of control actions are finite. ### Solution by Linear Programming
                                        The optimality equation can be solved by well known methods for policy iteration. Alternatively, as shown for example by Ross in "Introduction to 
  Stochastic Dynamic Programming" (Academic Press, 1983), an exact solution can be found by linear programming. We seek a stationary solution \\(V[x]\\) by minimizing \\(\sum_{x \in 0..N} V[x]\\) subject to \\[V[x] \geq a (p V[x + u] + q V[x-u])\\]
                                        for all feasible bets and all \\(x \\in 1..N-1\\) with boundary conditions \\(V[0]=0 \\) and \\(V[N]=N \\). The set of optimal wagers \\(u[x]\\) are found by determing the constraints that are active at optimality.
                                        \\(u[x]\\) may have multiple values.*/ /* Problem Parameters. Any of these can be adjusted in a data section. */ param N default 100,>= 1; # Goal param p default 0.25, >= 0,
                                        <=1 ; # Winning probability param q default 1-p,>= 0,
                                            <=1 -p; # Losing probability param B default N,>= 1,
                                                <=N ; # Maximum wager size param a default 1,>= 0,
                                                    <=1 ; # Discount factor /* Set of States */ set X:=0 ..N; /* Sets of possible wagers. These are parameterized by the State */ set U{x in X} :=1 ..min(B,min(N-x,x)); /* Value function */ var V{X}; /* Exact Linear Program Equivalent of the DP */ minimize
                                                        OBJ: sum{x in X} V[x] ; s.t. C1 {x in 1..N-1, u in U[x]}: V[x]>= a*(p*V[x+u] + q*V[x-u]); s.t. C2: V[0] = 0; s.t. C3: V[N] = N; solve; table tab1 {x in X} OUT "JSON" "Expected Value of the Initial Stake" "LineChart" : x~Stake, V[x]~ExpectedValue; printf " Goal =
                                                        %4d", N; printf "\n Maximum Bet = %4d", B; printf "\nWinning Probability = %8.3f", p ; printf "\n Losing Probability = %8.3f", q ; printf "\n Discount Factor = %8.3f", a; printf "\n\n %7s %10s %4s\n",'x','V[x]','u[x]:
                                                        Optimal Wagers'; printf " %7s %10s %4s" ,'-','----','---------------------'; for {x in X}{ printf "\n %7d %10.4f ",x, V[x]; printf {u in U[x]: abs(-V[x] + a*(p*V[x+u] + q*V[x-u]))
                                                        < 0.00001} " %3d",u; } end; </div>
                                </div>
                            </div>
                        </div>


                        <!-- modal Example -->
                        <div id="ModalExampleRAGambling" class="modal" role="dialog">
                            <div class="modal-dialog">
                                <div class="modal-content" style="width: 100%; background: #fff; border-radius:20px;">
                                    <div id="RAGambling" class="modal-body modal-body-example">
                                        /* # Stochastic Dynamic Programming: The Risk Averse Gambler ## Problem Statement A risk averse gambler with enters a game with the idea of betting for a fixed number of rounds \\(T\\). With a stake \\(x\\) and wager \\(u\\), the resulting state is either
                                        \\(x+u\\) with probability \\(p\\), or \\(x-u\\) with probability \\(q\\) where \\[p + q \leq 1\\] The wager must be an integer smaller than the current stake or the maximum wager established for the game. The total
                                        stake is limited to an amount \\(N\\). The gambler is risk averse where utility of the final stake is \\(\log(x)\\). Given an initial stake \\(x
                                        < N\\), calculate a strategy that maximizes the expected utility at the end of the game. ## Formulation of a Solution This is a classic problem in Stochastic Dynamic Programming. The function \\(V(k,x)\\) is the expected utility after of stake \\(x\\)
                                            after the \\(k^{th}\\) wager. The expected utility satisfies the optimality equation \\[V(k,x)=m ax_u [ p V(k+1,x+u) + q V(k+1,x-u) ]\\] where \\(V(T,x)=\ log(x)\\). The maximization is over the set of possible
                                            bets ranging from \\(0\\) to the minimum of \\(x\\), \\(N-x\\), or the bet limit \\(B\\). Note that the state space and set of control actions are finite. ## Solution by Linear Programming The optimality equation
                                            can be solved by well known methods for policy iteration. Alternatively, as shown for example by Ross in "Introduction to 
      Stochastic Dynamic Programming" (Academic Press, 1983), an exact solution can be found by linear programming. We seek a solution \\(V[k,x]\\) minimizing \\[\sum_{k=0}^{T-1}\sum_{x=0}^N V[k,x]\\] subject to \\[V[k,x] \geq p V[k+1,x+u] + q V[k+1,x-u]\\]
                                            for all feasible bets and boundary condition \\(V[T,x]=\ log(x)\\). The set of optimal wagers \\(u[x]\\) are found by determining the constraints that are active at optimality. */ /* Jeff Kantor December 18, 2009
                                            */ /* Problem Parameters. Any of these can be adjusted in a data section. */ param T default 5>= 1; # Stages param N default 50, >= 1; # Maximum Stake (reduce if computations are slow) param p default 0.55, >= 0,
                                            <=1 ; # Winning probability param q default 1-p,>= 0,
                                                <=1 -p; # Losing probability param B default N,>= 1,
                                                    <=N ; # Maximum wager size /* Set of States */ set X:=1 ..N; /* Sets of possible wagers. These are parameterized by the State */ set U{x in X} :=0 ..min(B,min(N-x,x-1)); /* Value function */ var V{0..T,X}>=0; /* Exact Linear Program Equivalent of the DP */ minimize OBJ: sum{t in 0..T-1, x in X} V[t,x] ; s.t. C1 {t in 0..T-1, x in 1..N, u in U[x]}: V[t,x] >= p*V[t+1,x+u] + q*V[t+1,x-u]; s.t. C2 {x in X}:
                                                        V[T,x] = log(x); solve; /* Find Optimal Wager */ param w{t in 0..T-1,x in 1..N} := if x==N then 0 else min{u in U[x]: abs(-V[t,x]+p*V[t+1,x+u]+q*V[t+1,x-u])
                                                        <0.000001} u; table tab1 {x in X} OUT "JSON" "Optimal Wager" "LineChart" : x, w[T-1,x]~Wager; table tab2 {x in X} OUT "JSON" "Expected Utility of the Initial Stake" "LineChart" : x, exp(V[T-1,x])~ExpectedUtility; printf "   Number of Wagers = %4d\n",
                                                            T; printf "      Maximum Stake = %4d\n", N; printf "        Maximum Bet = %4d\n", B; printf "Winning Probability = %8.3f\n", p ; printf " Losing Probability = %8.3f\n", q ; printf "\n  %7s ", ' ';
                                                            printf {t in 0..T-1} "   Wager %2s  ", t+1; printf "\n %7s ", 'Stake'; printf {t in 0..T-1} "   CE[x] u[x]"; printf "\n %7s ", '-----'; printf {t in 0..T-1} "   %9s ", '---------'; for {x in X}{
                                                            printf "\n %7d", x; printf {t in 0..T-1} "   %6.2f %3d", exp(V[t,x]), w[t,x]; } end; </div>
                                    </div>
                                </div>
                            </div>





                            <!-- container -->
                            <div id='container'>

                                <!-- Navigation Menu Bar -->
                                <nav class="navbar navbar-fixed-top navbar-inverse" role="navigation">
                                    <div class="container-fluid" style="background:#003b7b;">
                                        <div class="navbar-header">
                                            <a class="navbar-brand" href="#" style="color:#ffffff;">Solver MathProg</a>
                                        </div>

                                        <!-- Models menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="dropdown">
                                                <a href="#" style="background: #003b7b; color: #dddddd;">Modelo <span class="caret"></span></a>
                                                <ul class="dropdown-menu">
                                                    <li><a href="#" id="menuNew" onclick="document.getElementById('btnNewModel').click()">Novo</a></li>
                                                    <li><a href="#" id="menuOpen" onclick="document.getElementById('btnOpenModel').click()">Abrir ...</a></li>
                                                    <li><a href="#" id="menuSave">Salvar</a></li>
                                                </ul>
                                            </li>
                                        </ul>

                                        <!-- Examples menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="dropdown">
                                                <a href="#" style="background:#003b7b;color: #dddddd;">Exemplos <span class="caret"></span></a>
                                                <ul class="dropdown-menu">

                                                    <li class="dropdown-submenu">
                                                        <a href="#">MathProg - B&aacute;sicos <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="ExampleHelloWorld" onclick="copiarExemplo('helloWorld');">Hello, World</a></li>
                                                            <li><a id="lpTwoVars" onclick="copiarExemplo('lpTwoVars');">Linear Program in Two Variables</a></li>
                                                            <li><a id="linearEqns" onclick="copiarExemplo('linearEqns');">Linear Equations</a></li>
                                                            <li><a id="sets" onclick="copiarExemplo('sets');">Sets</a></li>
                                                            <li><a id="parameters" onclick="copiarExemplo('parameters');">Parameters</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href="#">Tabelas e Gr&aacute;ficos <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="ChartTools" onclick="copiarExemplo('chartTools');">Google Charts</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Agendameto <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="projectCPM" onclick="copiarExemplo('ProjectCPM');">Project Management with CPM</a></li>
                                                            <li><a id="jobShop" onclick="copiarExemplo('jobShop');">Job Shop Scheduling</a></li>
                                                            <li><a id="JesuitVols" onclick="copiarExemplo('Jesuit');">Jesuit Volunteers Corps</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Transporte e Atribui&ccedil;&otilde;es <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="TransportNet" onclick="copiarExemplo('transportationNetwork');">Transportation Network</a></li>
                                                            <li><a id="StockCutting" onclick="copiarExemplo('StockCutting');">Stock Cutting</a></li>
                                                            <li><a id="TableSeating" onclick="copiarExemplo('tableSeating');">Table Seating</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Rota otimizada <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="tsptw" onclick="copiarExemplo('tsptw');">Traveling Salesman with Time Windows</a></li>
                                                            <li><a id="vrp" onclick="copiarExemplo('vrp');">Vehicle Routing</a></li>
                                                            <li><a id="vrptw" onclick="copiarExemplo('vrptw');">Vehicle Routing with Time Windows</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Programação Estoc&aacute;stica <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="Newsvendor" onclick="copiarExemplo('theNewsvendorProblem');">Newsvendor Problem</a></li>
                                                            <li><a id="PlantExp" onclick="copiarExemplo('PlantExpansion');">Scenario Analysis for a Plant Expansion</a></li>
                                                            <li><a id="RNGambling" onclick="copiarExemplo('RNGambling');">Stochastic Dynamic Programming: Risk Neutral Gambler</a></li>
                                                            <li><a id="RAGambling" onclick="copiarExemplo('RAGambling')">Stochastic Dynamic Programming: Risk Averse Gambler</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Engenharia <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="DataReconciliation" onclick="copiarExemplo('DataReconciliation');">Data Reconciliation</a></li>
                                                            <li><a id="Solvay" onclick="copiarExemplo('solvay');">Generation/Consumption Analysis</a></li>
                                                        </ul>
                                                    </li>

                                                    <li class="dropdown-submenu">
                                                        <a href='#'>Finan&ccedil;as <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="retir" onclick="copiarExemplo('retirement');">Saving for Retirement</a></li>
                                                            <li><a id="PortfolioMAD" onclick="copiarExemplo('MAD');">Portfolio Optimization (MAD)</a></li>
                                                            <li><a id="AmericanCall" onclick="copiarExemplo('BPMACO');">American Call Option</a></li>
                                                            <li><a id="AmericanPut" onclick="copiarExemplo('BPMAPO');">American Put Option</a></li>
                                                            <li><a id="EuropeanCall" onclick="copiarExemplo('BPMECO');">European Call Option</a></li>
                                                            <li><a id="EuropeanPut" onclick="copiarExemplo('BPMEPO');">European Put Option</a></li>
                                                            <li><a id="Political" onclick="copiarExemplo('PoliticalArb');">Arbitrage in Political Markets</a></li>
                                                            <li><a id="RiskNeutralAI" onclick="copiarExemplo('RiskNeutral');">Risk Neutral Probabilities for American Idol</a></li>
                                                        </ul>
                                                    </li>


                                                    <li class="dropdown-submenu">
                                                        <a href='#'>T&eacute;cnicas Avan&ccedil;adas <span class="caret"></span></a>
                                                        <ul class="dropdown-menu">
                                                            <li><a id="MVNormal" onclick="copiarExemplo('Normal');">Sampling a Multivariate Normal Distribution</a></li>
                                                            <li><a id="PiecewiseLinearInterpolation" onclick="copiarExemplo('piecewise');">Piecewise Linear Interpolation</a></li>
                                                            <li><a id="Sort" onclick="copiarExemplo('Sorting')">Sorting</a></li>
                                                        </ul>
                                                    </li>

                                                </ul>
                                            </li>
                                        </ul>

                                        <!-- MathProg Resources menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="dropdown">
                                                <a href="#" style="color: #dddddd;">Resources <span class="caret"></span></a>
                                                <ul class="dropdown-menu">
                                                    <li><a rel="external" href='https://github.com/jckantor/MathProg-Solver/blob/master/libs/glpk-4.60/doc/gmpl.pdf'>GNU MathProg Reference</a></li>
                                                    <li><a rel="external" href='http://en.wikibooks.org/wiki/GLPK/GMPL_(MathProg)'>MathProg Wikibook</a></li>
                                                    <li><a rel="external" href='http://www.ampl.com/BOOK/download.html'>AMPL Book</a></li>
                                                    <li><a rel="external" href='http://iuuk.mff.cuni.cz/~bohm/texts/mathprog_intro.html'>MathProg in 60</a></li>
                                                </ul>
                                            </li>
                                        </ul>

                                        <!-- Sobre ... menu -->
                                        <ul class="nav navbar-nav">
                                            <li class="active">
                                                <a id='menuAbout' href="#" style="background: #003b7b; color: #dddddd;">Sobre</a>
                                            </li>
                                        </ul>

                                    </div>
                                    <!-- /.navbar-inner -->
                                </nav>
                                <!-- /.navbar-->

                                <div id='content' style="padding-top: 40px;">

                                    <!-- Instruction -->
                                    <div id='instructionContent' style="padding-top: 1px;"></div>
                                    <br>

                                    <!-- Model Editor -->
                                    <div style="margin-bottom: 10px;">
                                        <h4>Nome do arquivo</h4>
                                        <input type="text" id='modelFileName' class="NomeArquivo"></input>
                                    </div>
                                    <textarea id='editor'></textarea><br>

                                    <!-- Button Bar -->
                                    <div id='btnBar' style='width:100%;margin-top:1px;'>
                                        <div class="btn-group" style="float:left;">
                                            <button class="btn btn-primary bordaRedonda" id='btnNewModel' title='Limpar alterações e cria um novo modelo.'>Novo Modelo</button>
                                            <button class="btn btn-primary bordaRedonda" id='btnOpenModel' title='Abrir modelo de um arquivo.'>Abrir Modelo...</button>
                                            <input type="file" style="display: none;" id="inputOpenModel" name="inputOpenModel[]">
                                            <button class="btn btn-primary bordaRedonda" id='btnSaveModel' title='Salvar modelo em um arquivo.'>Salvar Modelo...</button>
                                        </div>
                                        <button class="btn btn-success" id='btnSolveModel' style='float: right;' title='Calcular uma solução para o modelo.'>Resolver</button>
                                    </div>
                                    <br>

                                    <!-- Message Panel -->
                                    <div id="messagePanel" style="min-height:38px;">
                                        <div id="message" class="alert" style="margin-top: 18px; margin-right: 0px;"></div>
                                    </div>

                                    <!-- Output Tabs -->
                                    <div class="tabbable" style="width: 100%; margin-top:0px; margin-bottom:0px;">
                                        <ul class="nav nav-tabs">
                                            <li class="active">
                                                <a href="#tab1" data-toggle="tab">
                                                    <h4 style="margin-top:3px; margin-bottom:3px;">Painel de Controle</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#outputTab" data-toggle="tab">
                                                    <h4 style="margin-top:3px; margin-bottom:3px;">Sa&iacute;da</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#dataTab" data-toggle="tab">
                                                    <h4 style="margin-top:3px; margin-bottom:3px;">Dados</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#variableTab" data-toggle="tab">
                                                    <h4 style="margin-top:3px; margin-bottom:3px;">Vari&aacute;veis</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#constraintTab" data-toggle="tab">
                                                    <h4 style="margin-top:3px; margin-bottom:3px;">Restri&ccedil;&otilde;es</h4>
                                                </a>
                                            </li>
                                            <li>
                                                <a href="#tab5" data-toggle="tab">
                                                    <h4 style="margin-top:3px; margin-bottom:3px;">Registros</h4>
                                                </a>
                                            </li>
                                        </ul>

                                        <div class="tab-content">

                                            <!-- Dashboard Pane -->
                                            <div class="tab-pane active" id="tab1">
                                                <div id='dashboardPanel' style="min-height: 380px;">
                                                    <table id='dashboardTable' class="table table-condensed table-bordered table-hover" style="width: 100%">
                                                        <tr>
                                                            <td>Tipo de Problema</td>
                                                            <td id="dashboardProb" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Objetivo</td>
                                                            <td id="dashboardObj" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Valor Objetivo</td>
                                                            <td id="dashboardObjVal" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Vari&aacute;veis Cont&iacute;nuas</td>
                                                            <td id="dashboardNvars" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Vari&aacute;veis inteiras n&atilde;o bin&eacute;rias</td>
                                                            <td id="dashboardNints" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>Vari&aacute;veis bin&aacute;rias</td>
                                                            <td id="dashboardNbins" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>N&uacute;mero de Vari&aacute;veis</td>
                                                            <td id="dashboardNcols" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>N&uacute;mero de Restri&ccedil;&otilde;es</td>
                                                            <td id="dashboardNrows" class="dashboardCell"></td>
                                                        </tr>
                                                        <tr>
                                                            <td>N&uacute;mero de coeficientes n&atilde;o zero</td>
                                                            <td id="dashboardNnz" class="dashboardCell"></td>
                                                        </tr>
                                                    </table>
                                                </div>
                                            </div>

                                            <!-- Model Output Pane -->
                                            <div class="tab-pane" id="outputTab" style="min-height: 380px;"></div>

                                            <!-- Data Sources Pane -->
                                            <div class="tab-pane" id="dataTab" style="min-height: 380px;"></div>

                                            <!-- Variables Pane -->
                                            <div class="tab-pane" id="variableTab" style="min-height: 380px; width: 100%;">
                                                <table class="table table-striped table-condensed" id="variableTableDiv"></table>
                                            </div>

                                            <!-- Constraints Pane -->
                                            <div class="tab-pane" id="constraintTab" style="min-height: 380px; width: 100%;">
                                                <table class="table table-striped table-condensed" id="constraintTableDiv"></table>
                                            </div>

                                            <!-- GLPK Log Pane-->
                                            <div class="tab-pane" id="tab5" style="min-height: 380px;">
                                                <pre id='logContent' style="width: 730px;min-height: 200px;"></pre><br>
                                            </div>

                                        </div>
                                        <!-- end of tab-content -->
                                    </div>
                                    <!-- end of tabtable -->
                                </div>
                                <!-- end of content -->

                            </div>
                            <!-- end of container -->

                            <script src="js/main.js"></script>

</body>

</html>